<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Matrix Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
  <style>
    /* CSS bleibt unver√§ndert */
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #f5f5f5;
      --border-color: #ccc;
      --text-color: #333;
      --canvas-border: #888;
      --active-tool-bg: #e0e0e0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--secondary-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      width: 100%;
      max-width: 1200px;
    }

    .controls, .canvas-container, .output-container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 280px;
    }

    .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #cv {
      border: 2px solid var(--canvas-border);
      cursor: crosshair; /* Standard-Cursor */
      margin-bottom: 15px;
       /* Verhindert das Ziehen von Bildern */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      /* WICHTIG: Verhindert Standard-Browserverhalten bei Drag-Events auf dem Canvas */
      touch-action: none;
    }

     #cv.eyedropper-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z'/><path d='M12 14l6.36-6.36'/><path d='M8.5 8.5l7 7'/></svg>") 8 8, crosshair;
    }

    #cv.fill-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black'><path d='M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 18v-6h4v6h-4z'/></svg>") 8 16, pointer; /* Farbeimer-artiger Cursor */
    }

    .control-group {
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 15px;
    }

    .control-group legend {
      font-weight: bold;
      padding: 0 5px;
      color: var(--primary-color);
    }

     .control-group label,
     .control-group button {
        margin-bottom: 8px; /* F√ºgt etwas Platz unter Labels und Buttons hinzu */
     }

    .control-group input[type="number"],
    .control-group input[type="text"] {
      width: calc(100% - 16px); /* Volle Breite minus Padding */
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-top: 4px;
    }

    .control-group input[type="checkbox"] {
        margin-right: 5px;
        vertical-align: middle;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      font-size: 1em;
      margin: 5px 2px; /* Etwas Rand hinzugef√ºgt */
      display: inline-flex; /* Richtet Icon und Text aus */
      align-items: center; /* Richtet Icon und Text aus */
      gap: 5px; /* Platz zwischen Icon und Text */
    }

    button:hover {
      background-color: #3a7ac2;
    }

    button.secondary {
        background-color: #6c757d;
    }
    button.secondary:hover {
        background-color: #5a6268;
    }

    button.danger {
        background-color: #dc3545;
    }
    button.danger:hover {
        background-color: #c82333;
    }

    button.tool-button.active {
        background-color: var(--active-tool-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }

    #color-picker-container {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    .iro__slider {
        border-radius: 4px; /* Leicht abgerundeter Slider */
    }
    .iro__marker {
        border: 2px solid white; /* Macht den Marker sichtbarer */
        box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }

    .color-input-group {
        display: flex;
        gap: 5px;
        align-items: center;
    }
     .color-input-group input[type="text"] {
        flex-grow: 1;
        margin-top: 0; /* √úberschreibt allgemeinen Rand */
        margin-bottom: 0; /* √úberschreibt allgemeinen Rand */
     }
    .color-input-group button {
        padding: 8px 10px;
        margin: 0; /* √úberschreibt allgemeinen Rand */
    }

    #matrix {
      white-space: pre;
      font-family: 'Courier New', Courier, monospace;
      background-color: #e9e9e9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid var(--border-color);
      max-height: 400px;
      overflow: auto;
      text-align: left;
      line-height: 1.4;
    }

    /* Einfache Icons mit Zeichen f√ºr Demo */
     .icon-fill::before { content: "üíß"; margin-right: 4px;}
     .icon-eyedropper::before { content: "üß™"; margin-right: 4px; }
     .icon-draw::before { content: "‚úèÔ∏è"; margin-right: 4px; }
     .icon-reset::before { content: "üîÑ"; margin-right: 4px; }
     .icon-export::before { content: "üíæ"; margin-right: 4px; }
     .icon-grid::before { content: "‚ñ¶"; margin-right: 4px; }
     .icon-done::before { content: "‚úÖ"; margin-right: 4px; }
     .icon-blackify::before { content: "‚¨õ"; margin-right: 4px; }
  </style>
</head>

<body>
  <h1>Pixel Matrix Editor</h1>

  <div class="container">

    <div class="controls">
      <fieldset class="control-group">
        <legend>Grid Settings</legend>
        <label for="grid-size">Grid Size (N x N):</label>
        <input type="number" id="grid-size" value="8" min="4" max="64">
        <label for="cell-size">Cell Size (px):</label>
        <input type="number" id="cell-size" value="30" min="5" max="50">
        <button id="update-grid">Update Grid</button>
      </fieldset>

      <fieldset class="control-group">
        <legend>Color</legend>
        <div id="color-picker-container">
          <div id="color-picker"></div> <!-- Wird von iro.js gef√ºllt -->
        </div>
         <div class="color-input-group">
            <input type="text" id="color-input" placeholder="#rrggbb">
            <button id="color-input-ok" title="Set color from input">OK</button>
         </div>
        <div>
          <input type="checkbox" id="changeforall" style="vertical-align: middle;">
          <label for="changeforall">Apply to all non-white/transparent pixels</label>
        </div>
      </fieldset>

       <fieldset class="control-group">
            <legend>Tools (Active: <span id="current-tool-display">Draw</span>)</legend>
            <button id="tool-draw" class="tool-button active icon-draw" title="Draw/Erase Tool (Left/Right Click)">Draw</button>
            <button id="tool-fill" class="tool-button icon-fill" title="Fill Tool">Fill</button>
            <button id="tool-eyedropper" class="tool-button icon-eyedropper" title="Eyedropper Tool">Pick Color</button>
        </fieldset>

      <fieldset class="control-group">
        <legend>Actions</legend>
        <button id="done" class="icon-done">Generate Matrix</button>
        <button id="reset" class="secondary icon-reset">Reset Grid</button>
        <button id="blackify" class="secondary icon-blackify">Fill Blank with Black</button>
         <button id="toggle-gridlines" class="secondary icon-grid">Toggle Grid Lines</button>
        <button id="export-png" class="icon-export">Export as PNG</button>
      </fieldset>
    </div>

    <div class="canvas-container">
      <canvas id="cv"></canvas>
    </div>

    <div class="output-container">
      <h2>Matrix Output</h2>
      <div id="matrix">Click "Generate Matrix" to see the output here.</div>
    </div>

  </div>

  <script>
    // Warten bis DOM geladen ist
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded. Initializing Pixel Editor...");

        // --- Elemente holen ---
        const canvas = document.getElementById("cv");
        const matrixDiv = document.getElementById("matrix");
        const btnGenerateMatrix = document.getElementById("done");
        const btnReset = document.getElementById("reset");
        const btnBlackify = document.getElementById("blackify");
        const btnExportPng = document.getElementById("export-png");
        const btnUpdateGrid = document.getElementById("update-grid");
        const btnToggleGridlines = document.getElementById("toggle-gridlines");
        const inputGridSize = document.getElementById("grid-size");
        const inputCellSize = document.getElementById("cell-size");
        const inputChangeAll = document.getElementById("changeforall");
        const inputColorHex = document.getElementById("color-input");
        const btnColorInputOk = document.getElementById("color-input-ok");
        const toolDrawBtn = document.getElementById('tool-draw');
        const toolFillBtn = document.getElementById('tool-fill');
        const toolEyedropperBtn = document.getElementById('tool-eyedropper');
        const currentToolDisplay = document.getElementById('current-tool-display');
        const colorPickerContainer = document.getElementById('color-picker'); // Nur der Container

        // --- Globale Zustandsvariablen ---
        let paperScope; // Der Paper.js Kontext
        let paths = []; // Array f√ºr {x, y, pixel: paper.Path}
        let gridSize = 8;
        let cellSize = 30;
        let currColor; // Die aktuell ausgew√§hlte paper.Color
        let isMouseDown = false;
        let lastPaintedCoords = { x: -1, y: -1 };
        let showGridLines = true;
        let currentTool = 'draw';
        let whiteColor; // Referenz auf paper.Color('white')
        let blackColor; // Referenz auf paper.Color('black')
        const TRANSPARENT_KEY = '__TRANSPARENT__'; // Schl√ºssel f√ºr Mapping

        // --- Color Picker Initialisierung (iro.js) ---
        // WICHTIG: Sicherstellen, dass dies nicht fehlschl√§gt.
        let colorPickerInstance;
        try {
             colorPickerInstance = new iro.ColorPicker(colorPickerContainer, {
                width: 200,
                color: "#ffffff", // Start mit Wei√ü
                borderWidth: 1,
                borderColor: "#ccc",
                layout: [
                    { component: iro.ui.Wheel },
                    { component: iro.ui.Box },
                    { component: iro.ui.Slider, options: { sliderType: 'hue' } },
                    { component: iro.ui.Slider, options: { sliderType: 'saturation' } },
                    { component: iro.ui.Slider, options: { sliderType: 'value' } },
                ]
            });
            console.log("iro.js Color Picker initialized.");
        } catch (error) {
            console.error("FATAL: Failed to initialize iro.js Color Picker!", error);
            alert("Error initializing color picker. Please check console.");
            return; // Abbruch, wenn der Picker nicht geht
        }

        // --- Hauptfunktionen ---

        // Grid erstellen / neu erstellen
        function createGrid() {
            console.log("Attempting to create grid...");
            try {
                // Altes Projekt bereinigen
                if (paperScope && paperScope.project) {
                    paperScope.project.clear();
                    console.log("Cleared previous paper project.");
                }

                // Neuen Paper.js Scope aufsetzen
                paperScope = new paper.PaperScope();
                paperScope.setup(canvas);
                console.log("paperScope setup complete on canvas.");

                // Wichtige Farben initialisieren *nach* setup
                whiteColor = new paperScope.Color('white');
                blackColor = new paperScope.Color('black');
                // Startfarbe setzen (explizit wei√ü) und UI synchronisieren
                currColor = whiteColor.clone(); // Sicherstellen, dass es ein Klon ist
                colorPickerInstance.color.hexString = currColor.toHex();
                inputColorHex.value = currColor.toHex();
                console.log("Initialized base colors (white, black) and set current color to white.");

                // Grid-Parameter holen
                paths = []; // Array leeren
                gridSize = parseInt(inputGridSize.value, 10) || 8; // Basis 10 und Fallback
                cellSize = parseInt(inputCellSize.value, 10) || 30;
                const totalSize = gridSize * cellSize;
                if (totalSize <= 0) {
                   throw new Error(`Invalid grid dimensions: Size=${gridSize}, Cell=${cellSize}`);
                }
                canvas.width = totalSize;
                canvas.height = totalSize;
                paperScope.view.viewSize = new paperScope.Size(totalSize, totalSize);
                console.log(`Grid dimensions set: ${gridSize}x${gridSize}, Cell: ${cellSize}px, Total: ${totalSize}px`);

                // Pfade erstellen
                const strokeColor = showGridLines ? blackColor : null;
                console.log(`Creating paths... Stroke active: ${showGridLines}`);
                for (let i = 0; i < gridSize; i++) { // Spalte (x)
                    for (let j = 0; j < gridSize; j++) { // Reihe (y)
                        const rect = new paperScope.Rectangle(i * cellSize, j * cellSize, cellSize, cellSize);
                        const path = new paperScope.Path.Rectangle(rect);

                        path.fillColor = null; // Start transparent
                        path.strokeColor = strokeColor ? strokeColor.clone() : null; // Klon oder null
                        path.strokeWidth = 1;
                        path.gridX = i;
                        path.gridY = j;

                        // Event Listeners f√ºr diesen Pfad
                        path.onMouseDown = function(event) {
                            event.preventDefault();
                            isMouseDown = true;
                            handlePixelClick(this, event); // 'this' ist der geklickte Path
                        };
                        path.onMouseEnter = function(event) {
                            if (isMouseDown) {
                                handlePixelClick(this, event, true); // 'this' ist der Path
                            }
                        };

                        // Pfad speichern (Index = x * gridSize + y)
                        paths[i * gridSize + j] = { x: i, y: j, pixel: path };
                    }
                }
                console.log(`Created ${paths.length} paths.`);

                // Globale Maus-Events f√ºr den View
                paperScope.view.onMouseUp = () => {
                    if (isMouseDown) {
                        isMouseDown = false;
                        lastPaintedCoords = { x: -1, y: -1 };
                    }
                };
                paperScope.view.onMouseLeave = () => {
                     if (isMouseDown) {
                         isMouseDown = false;
                         lastPaintedCoords = { x: -1, y: -1 };
                     }
                 };

                // Kontextmen√º verhindern
                canvas.removeEventListener('contextmenu', preventContextMenu); // Erst entfernen, falls schon vorhanden
                canvas.addEventListener('contextmenu', preventContextMenu);

                // Alles zeichnen
                paperScope.view.draw();
                console.log("Grid creation complete. Initial draw performed.");

            } catch (error) {
                console.error("FATAL ERROR during createGrid:", error);
                alert("Failed to create grid. Check console for details. Error: " + error.message);
                // Hier k√∂nnten wir versuchen, die UI zu deaktivieren oder eine Meldung anzuzeigen
            }
        }

        // Hilfsfunktion, um Kontextmen√º zu verhindern
        function preventContextMenu(e) {
            e.preventDefault();
        }

        // Pixel-Klick/Drag-Handler
        function handlePixelClick(path, event, isDrag = false) {
           // console.log("handlePixelClick called"); // Test, ob Funktion erreicht wird
            // Sicherheitscheck: Ist paperScope noch g√ºltig?
             if (!paperScope || !path || !currColor || !whiteColor) {
                console.error("handlePixelClick: Missing critical variable (paperScope, path, currColor, or whiteColor). Aborting.");
                return;
            }

            const isLeftClick = event.event.button === 0;
            const isRightClick = event.event.button === 2;

            if (isDrag && path.gridX === lastPaintedCoords.x && path.gridY === lastPaintedCoords.y) {
                 return; // Nichts zu tun
            }
            // console.log(`Click: Tool=${currentTool}, L=${isLeftClick}, R=${isRightClick}, Color=${currColor.toCSS()}, Target=(${path.gridX},${path.gridY}), CurrentFill=${path.fillColor?.toCSS()}`);

            let redrawNeeded = false;

            try { // F√ºge try-catch hinzu, um Fehler hier abzufangen
                switch (currentTool) {
                    case 'draw':
                        if (isLeftClick) {
                            if (!path.fillColor || !path.fillColor.equals(currColor)) {
                               path.fillColor = currColor.clone(); // Klonen!
                               redrawNeeded = true;
                            }
                        } else if (isRightClick) {
                            if (path.fillColor !== null) { // Nur wenn nicht schon transparent
                               path.fillColor = null;
                               redrawNeeded = true;
                            }
                        }
                        break;
                    case 'fill':
                        if (isLeftClick) {
                             floodFill(path.gridX, path.gridY, currColor); // floodFill macht eigenes draw
                             redrawNeeded = false; // Verhindert doppeltes Zeichnen
                        }
                        break;
                     case 'eyedropper':
                         if (isLeftClick) {
                             const pickedColorObj = path.fillColor ? path.fillColor.clone() : whiteColor.clone(); // Klonen!
                             console.log(`Eyedropper: Picked ${pickedColorObj.toCSS()}`);
                             colorPickerInstance.color.hexString = pickedColorObj.toHex();
                             inputColorHex.value = pickedColorObj.toHex();
                             currColor = pickedColorObj; // Objekt direkt √ºbernehmen (ist schon Klon)
                             setActiveTool('draw'); // Zur√ºck zum Zeichnen
                         }
                         break;
                }
            } catch (error) {
                 console.error("Error during handlePixelClick action:", error);
            }

            lastPaintedCoords = { x: path.gridX, y: path.gridY };
            if (redrawNeeded) {
                paperScope.view.draw(); // Nur zeichnen, wenn n√∂tig
            }
        }

        // Flood Fill (unver√§ndert zur letzten Version, aber mit Checks)
        function floodFill(startX, startY, newColor) {
             if (!paperScope) { console.error("floodFill: paperScope missing."); return; }

            const targetPathObj = getPixelPath(startX, startY);
            if (!targetPathObj) { console.error(`floodFill: Path at (${startX}, ${startY}) not found.`); return; }

            const targetColor = targetPathObj.pixel.fillColor; // Kann null sein
            const isNewColorNull = !newColor;
            const isTargetColorNull = !targetColor;

            if (isNewColorNull && isTargetColorNull) return;
            if (!isNewColorNull && !isTargetColorNull && newColor.equals(targetColor)) return;

            const queue = [{ x: startX, y: startY }];
            const visited = new Set([`${startX},${startY}`]);
            let pixelsChanged = 0;

             while (queue.length > 0) {
                const { x, y } = queue.shift();
                const currentPathObj = getPixelPath(x, y);
                if (!currentPathObj) continue;

                currentPathObj.pixel.fillColor = newColor ? newColor.clone() : null;
                pixelsChanged++;

                const neighbors = [ { nx: x, ny: y - 1 }, { nx: x, ny: y + 1 }, { nx: x - 1, ny: y }, { nx: x + 1, ny: y } ];

                for (const { nx, ny } of neighbors) {
                     const neighborKey = `${nx},${ny}`;
                     if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited.has(neighborKey)) {
                        const neighborPathObj = getPixelPath(nx, ny);
                         if (neighborPathObj) {
                            const neighborColor = neighborPathObj.pixel.fillColor;
                            const isNeighborColorNull = !neighborColor;
                            let match = false;
                            if (isTargetColorNull && isNeighborColorNull) match = true;
                            else if (!isTargetColorNull && !isNeighborColorNull && targetColor.equals(neighborColor)) match = true;

                            if (match) {
                                visited.add(neighborKey);
                                queue.push({ x: nx, y: ny });
                            }
                         }
                     }
                 }
            }
            if (pixelsChanged > 0) {
                paperScope.view.draw();
            }
        }

        // Hilfsfunktion: Pixelpfad holen (unver√§ndert)
        function getPixelPath(x, y) {
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                const index = x * gridSize + y;
                if (index < paths.length && paths[index]) { // Zus√§tzlicher Check auf Existenz
                  return paths[index];
                }
            }
            // console.warn(`getPixelPath: Path not found for (${x}, ${y})`); // Weniger aggressives Logging
            return null;
        }

        // Werkzeug aktivieren (unver√§ndert)
        function setActiveTool(toolName) {
            currentTool = toolName;
            currentToolDisplay.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`tool-${toolName}`);
            if (activeBtn) activeBtn.classList.add('active');

            canvas.classList.remove('eyedropper-cursor', 'fill-cursor');
            if (toolName === 'eyedropper') canvas.classList.add('eyedropper-cursor');
            else if (toolName === 'fill') canvas.classList.add('fill-cursor');
        }

        // Matrix generieren (letzte korrekte Version)
        function generateMatrix() {
            // Verwende die letzte korrigierte Version dieser Funktion
            if (!paperScope || !paths || paths.length === 0 || !whiteColor) {
                matrixDiv.textContent = "Grid/State not properly initialized.";
                console.error("generateMatrix: Missing prerequisites (paperScope, paths, whiteColor).");
                return;
            }
            console.log("Generating Matrix...");

            let colorMap = {}; // Map: Farb-Schl√ºssel (Hex oder TRANSPARENT_KEY) -> Zeichen { key: char }
            let colorDefinitions = {}; // Map: Farb-Schl√ºssel -> RGB-Array { key: [r, g, b] }
            let charCode = 97; // 'a'
            const whiteHex = whiteColor.toHex();

            paths.forEach(p => { // Gehe jeden gespeicherten Pfad durch
                if (!p || !p.pixel) return; // Sicherheitscheck
                const color = p.pixel.fillColor;
                let key;
                let isRealColor = false;

                if (color) {
                    key = color.toHex();
                    if (key !== whiteHex) {
                        isRealColor = true;
                    } else {
                        key = TRANSPARENT_KEY; // Wei√ü wird wie transparent behandelt
                    }
                } else {
                    key = TRANSPARENT_KEY; // null ist transparent
                }

                if (isRealColor && !(key in colorMap)) {
                    const char = String.fromCharCode(charCode++);
                    colorMap[key] = char;
                    try { // Sicherstellen, dass Farbkonvertierung klappt
                       colorDefinitions[key] = [
                            Math.round(color.red * 255),
                            Math.round(color.green * 255),
                            Math.round(color.blue * 255)
                        ];
                    } catch(e) {
                         console.error(`Error converting color ${key} to RGB`, e);
                         colorDefinitions[key] = null; // Mark as error
                    }
                    // console.log(`Mapped color ${key} to char '${char}' (RGB: ${colorDefinitions[key]})`);
                }
            });

            let matrixOutput = "Color Definitions:\n";
            for (const key in colorMap) {
                if (key !== TRANSPARENT_KEY) {
                    const char = colorMap[key];
                    const rgb = colorDefinitions[key]; // Hole das RGB Array
                    if (rgb && Array.isArray(rgb) && rgb.length === 3) {
                        matrixOutput += `${char} = (${rgb.join(',')}) - ${key}\n`;
                    } else {
                         matrixOutput += `${char} = (Error retrieving RGB) - ${key}\n`; // Fehler ausgeben
                    }
                }
            }
            matrixOutput += "\nMatrix:\n";

            for (let j = 0; j < gridSize; j++) { // Reihen (y)
                let rowChars = [];
                for (let i = 0; i < gridSize; i++) { // Spalten (x)
                    const pathObj = getPixelPath(i, j);
                    let char = '.'; // Standard
                    let key = TRANSPARENT_KEY;

                    if (pathObj && pathObj.pixel && pathObj.pixel.fillColor) {
                        const currentHex = pathObj.pixel.fillColor.toHex();
                        if (currentHex !== whiteHex) {
                            key = currentHex; // Es ist eine "echte" Farbe
                        }
                        // Wenn wei√ü, bleibt key TRANSPARENT_KEY
                    }
                     // Wenn null, bleibt key TRANSPARENT_KEY

                    if (key !== TRANSPARENT_KEY && key in colorMap) {
                        char = colorMap[key]; // Zeichen holen
                    } else if (key !== TRANSPARENT_KEY) {
                        char = '?'; // Farbe nicht gemappt? Fehler.
                    }
                    rowChars.push(char);
                }
                matrixOutput += rowChars.join(", ") + (j < gridSize - 1 ? "," : "") + "\n";
            }

            matrixDiv.textContent = matrixOutput;
            console.log("Matrix generation complete.");
        }


        // --- Event Listener f√ºr Buttons und Inputs ---

        // Color Picker Event
        colorPickerInstance.on('color:change', (color) => {
          if (!paperScope || !currColor) return; // Nur wenn alles initialisiert ist
          const newColor = new paperScope.Color(color.hexString);

          if (!currColor.equals(newColor)) { // Nur wenn Farbe sich *wirklich* √§ndert
                // console.log("Picker changed color to:", newColor.toCSS());
                currColor = newColor;
                inputColorHex.value = currColor.toHex();

                // "Change for all" Logik
                if (inputChangeAll.checked && paths.length > 0 && whiteColor) {
                    paths.forEach(p => {
                        if (p && p.pixel && p.pixel.fillColor && !p.pixel.fillColor.equals(whiteColor)) {
                             p.pixel.fillColor = currColor.clone();
                        }
                     });
                     paperScope.view.draw();
                }
          }
        });

        // Button: Update Grid
        btnUpdateGrid.addEventListener('click', createGrid); // Ruft die Hauptfunktion auf

        // Button: Generate Matrix
        btnGenerateMatrix.addEventListener('click', generateMatrix); // Ruft die separate Funktion auf

        // Button: Reset Grid
        btnReset.addEventListener('click', () => {
            if (!paperScope || !paths || !whiteColor) return;
            console.log("Resetting grid.");
            paths.forEach(p => { if (p && p.pixel) p.pixel.fillColor = null; });
            colorPickerInstance.color.hexString = '#ffffff';
            inputColorHex.value = '#ffffff';
            currColor = whiteColor.clone();
            matrixDiv.textContent = 'Grid reset. Click "Generate Matrix" again.';
            paperScope.view.draw();
        });

        // Button: Blackify
        btnBlackify.addEventListener('click', () => {
            if (!paperScope || !paths || !whiteColor || !blackColor) return;
            console.log("Blackifying blank/white pixels.");
            let changed = 0;
            paths.forEach(p => {
                if (p && p.pixel && (!p.pixel.fillColor || p.pixel.fillColor.equals(whiteColor))) {
                    p.pixel.fillColor = blackColor.clone();
                    changed++;
                }
            });
            if (changed > 0) paperScope.view.draw();
        });

        // Button: Toggle Gridlines
         btnToggleGridlines.addEventListener('click', () => {
             if (!paperScope || !paths || !blackColor) return;
             showGridLines = !showGridLines;
             const stroke = showGridLines ? blackColor : null;
             paths.forEach(p => {
                 if (p && p.pixel) p.pixel.strokeColor = stroke ? stroke.clone() : null;
             });
             const textNode = Array.from(btnToggleGridlines.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
             if(textNode) textNode.nodeValue = showGridLines ? ' Hide Grid Lines' : ' Show Grid Lines';
             btnToggleGridlines.classList.toggle('icon-grid', showGridLines);
             paperScope.view.draw();
         });

        // Button: Export PNG
        btnExportPng.addEventListener('click', () => {
             if (!paperScope || !paperScope.view || !paperScope.view.element) {
                 console.error("Export PNG: PaperScope or view not ready.");
                 return;
             }
            console.log("Exporting as PNG...");
            paperScope.view.draw(); // Sicherstellen, dass alles aktuell ist

            const originalStrokes = [];
            let strokesChanged = false;
            if (showGridLines) {
                paths.forEach(p => {
                   if (p && p.pixel && p.pixel.strokeColor) {
                     originalStrokes.push({ path: p.pixel, strokeColor: p.pixel.strokeColor, strokeWidth: p.pixel.strokeWidth });
                     p.pixel.strokeColor = null;
                     strokesChanged = true;
                   }
                });
                if (strokesChanged) paperScope.view.draw(); // Neuzeichnen ohne Linien
            }

            try {
                const canvasElement = paperScope.view.element;
                const dataURL = canvasElement.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = 'pixel-art.png';
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                 console.error("Error during PNG export:", error);
                 alert("Failed to export PNG. Check console.");
            }

            // Linien wiederherstellen
            if (strokesChanged) {
                originalStrokes.forEach(item => {
                   if(item.path) {
                       item.path.strokeColor = item.strokeColor;
                       item.path.strokeWidth = item.strokeWidth;
                   }
                });
                 paperScope.view.draw();
            }
        });

        // Input + OK f√ºr Farbe
        btnColorInputOk.addEventListener('click', () => {
            if (!paperScope || !currColor || !colorPickerInstance) return;
            const hexValue = inputColorHex.value.trim();
            try {
                if (/^#([0-9A-F]{3}){1,2}$/i.test(hexValue)) {
                   const newColor = new paperScope.Color(hexValue);
                   colorPickerInstance.color.hexString = newColor.toHex(); // Picker aktualisieren
                   currColor = newColor; // Globale Farbe aktualisieren
                   console.log("Color set from input:", currColor.toCSS());
                } else {
                    throw new Error("Invalid hex format. Use #rrggbb or #rgb.");
                }
            } catch (e) {
                console.error("Invalid color input:", hexValue, e);
                alert(e.message || "Invalid color format.");
                inputColorHex.value = currColor.toHex(); // Auf alten Wert zur√ºcksetzen
            }
        });
        inputColorHex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                btnColorInputOk.click();
            }
        });

        // Tool Buttons
        toolDrawBtn.addEventListener('click', () => setActiveTool('draw'));
        toolFillBtn.addEventListener('click', () => setActiveTool('fill'));
        toolEyedropperBtn.addEventListener('click', () => setActiveTool('eyedropper'));

        // --- Initialer Start ---
        try {
            setActiveTool('draw'); // Standardwerkzeug setzen
            createGrid(); // Das erste Grid erstellen
            console.log("Pixel Matrix Editor Initialized Successfully.");
        } catch (error) {
            console.error("Error during initial setup:", error);
            alert("Failed to initialize the editor. Please check the console.");
        }

    }); // Ende DOMContentLoaded
  </script>
</body>
</html>
