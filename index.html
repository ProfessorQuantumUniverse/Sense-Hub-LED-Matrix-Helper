<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Matrix Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
  <style>
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #f5f5f5;
      --border-color: #ccc;
      --text-color: #333;
      --canvas-border: #888;
      --active-tool-bg: #e0e0e0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--secondary-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      width: 100%;
      max-width: 1200px;
    }

    .controls, .canvas-container, .output-container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 280px;
    }

    .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #cv {
      border: 2px solid var(--canvas-border);
      cursor: crosshair; /* Default cursor */
      margin-bottom: 15px;
       /* Prevent image dragging */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

     #cv.eyedropper-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z'/><path d='M12 14l6.36-6.36'/><path d='M8.5 8.5l7 7'/></svg>") 8 8, crosshair;
    }

    #cv.fill-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black'><path d='M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 18v-6h4v6h-4z'/></svg>") 8 16, pointer; /* Paint bucket-like cursor */
    }


    .control-group {
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 15px;
    }

    .control-group legend {
      font-weight: bold;
      padding: 0 5px;
      color: var(--primary-color);
    }

     .control-group label,
     .control-group button {
        margin-bottom: 8px; /* Add some space below labels and buttons */
     }

    .control-group input[type="number"],
    .control-group input[type="text"] {
      width: calc(100% - 16px); /* Full width minus padding */
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-top: 4px;
    }

    .control-group input[type="checkbox"] {
        margin-right: 5px;
        vertical-align: middle;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      font-size: 1em;
      margin: 5px 2px; /* Added some margin */
      display: inline-flex; /* Align icon and text */
      align-items: center; /* Align icon and text */
      gap: 5px; /* Space between icon and text */
    }

    button:hover {
      background-color: #3a7ac2;
    }

    button.secondary {
        background-color: #6c757d;
    }
    button.secondary:hover {
        background-color: #5a6268;
    }

    button.danger {
        background-color: #dc3545;
    }
    button.danger:hover {
        background-color: #c82333;
    }

    button.tool-button.active {
        background-color: var(--active-tool-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }


    #color-picker-container {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    .iro__slider {
        border-radius: 4px; /* Slightly round slider */
    }
    .iro__marker {
        border: 2px solid white; /* Make marker more visible */
        box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }

    .color-input-group {
        display: flex;
        gap: 5px;
        align-items: center;
    }
     .color-input-group input[type="text"] {
        flex-grow: 1;
        margin-top: 0; /* Override general margin */
        margin-bottom: 0; /* Override general margin */
     }
    .color-input-group button {
        padding: 8px 10px;
        margin: 0; /* Override general margin */
    }


    #matrix {
      white-space: pre;
      font-family: 'Courier New', Courier, monospace;
      background-color: #e9e9e9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid var(--border-color);
      max-height: 400px;
      overflow: auto;
      text-align: left;
      line-height: 1.4;
    }

    /* Simple icons using characters for demo */
     .icon-fill::before { content: "üíß"; margin-right: 4px;}
     .icon-eyedropper::before { content: "üß™"; margin-right: 4px; }
     .icon-draw::before { content: "‚úèÔ∏è"; margin-right: 4px; }
     .icon-reset::before { content: "üîÑ"; margin-right: 4px; }
     .icon-export::before { content: "üíæ"; margin-right: 4px; }
     .icon-grid::before { content: "‚ñ¶"; margin-right: 4px; }
     .icon-done::before { content: "‚úÖ"; margin-right: 4px; }
     .icon-blackify::before { content: "‚¨õ"; margin-right: 4px; }

  </style>
</head>

<body>
  <h1>Pixel Matrix Editor</h1>

  <div class="container">

    <div class="controls">
      <fieldset class="control-group">
        <legend>Grid Settings</legend>
        <label for="grid-size">Grid Size (N x N):</label>
        <input type="number" id="grid-size" value="8" min="4" max="64">
        <label for="cell-size">Cell Size (px):</label>
        <input type="number" id="cell-size" value="30" min="5" max="50">
        <button id="update-grid">Update Grid</button>
      </fieldset>

      <fieldset class="control-group">
        <legend>Color</legend>
        <div id="color-picker-container">
          <div id="color-picker"></div>
        </div>
         <div class="color-input-group">
            <input type="text" id="color-input" placeholder="#rrggbb">
            <button id="color-input-ok" title="Set color from input">OK</button>
         </div>
        <div>
          <input type="checkbox" id="changeforall" style="vertical-align: middle;">
          <label for="changeforall">Apply to all colored pixels</label>
        </div>
      </fieldset>

       <fieldset class="control-group">
            <legend>Tools (Active: <span id="current-tool-display">Draw</span>)</legend>
            <button id="tool-draw" class="tool-button active icon-draw" title="Draw/Erase Tool (Left/Right Click)">Draw</button>
            <button id="tool-fill" class="tool-button icon-fill" title="Fill Tool">Fill</button>
            <button id="tool-eyedropper" class="tool-button icon-eyedropper" title="Eyedropper Tool">Pick Color</button>
        </fieldset>

      <fieldset class="control-group">
        <legend>Actions</legend>
        <button id="done" class="icon-done">Generate Matrix</button>
        <button id="reset" class="secondary icon-reset">Reset Grid</button>
        <button id="blackify" class="secondary icon-blackify">Fill Blank with Black</button>
         <button id="toggle-gridlines" class="secondary icon-grid">Toggle Grid Lines</button>
        <button id="export-png" class="icon-export">Export as PNG</button>
      </fieldset>
    </div>

    <div class="canvas-container">
      <canvas id="cv"></canvas>
      <!-- Canvas size will be set dynamically by JS -->
    </div>

    <div class="output-container">
      <h2>Matrix Output</h2>
      <div id="matrix">Click "Generate Matrix" to see the output here.</div>
    </div>

  </div>

  <script>
    const canvas = document.getElementById("cv");
    const ctx = canvas.getContext('2d'); // Needed for PNG export and potentially other ops
    const matrixDiv = document.getElementById("matrix");

    // --- Control Elements ---
    const btnGenerateMatrix = document.getElementById("done");
    const btnReset = document.getElementById("reset");
    const btnBlackify = document.getElementById("blackify");
    const btnExportPng = document.getElementById("export-png");
    const btnUpdateGrid = document.getElementById("update-grid");
    const btnToggleGridlines = document.getElementById("toggle-gridlines");
    const inputGridSize = document.getElementById("grid-size");
    const inputCellSize = document.getElementById("cell-size");
    const inputChangeAll = document.getElementById("changeforall");
    const inputColorHex = document.getElementById("color-input");
    const btnColorInputOk = document.getElementById("color-input-ok");
    const toolDrawBtn = document.getElementById('tool-draw');
    const toolFillBtn = document.getElementById('tool-fill');
    const toolEyedropperBtn = document.getElementById('tool-eyedropper');
    const currentToolDisplay = document.getElementById('current-tool-display');
    const colorPickerContainer = document.getElementById('color-picker');

    // --- State Variables ---
    let paperScope; // Hold the paper.js scope
    let paths = []; // Store path objects {x, y, pixel}
    let gridSize = 8;
    let cellSize = 30;
    let currColor = new paper.Color('white'); // Use paper.Color
    let isMouseDown = false;
    let lastPaintedCoords = { x: -1, y: -1 }; // For smoother dragging
    let showGridLines = true;
    let currentTool = 'draw'; // 'draw', 'fill', 'eyedropper'

    // --- Setup Color Picker ---
    const colorPicker = new iro.ColorPicker(colorPickerContainer, {
        width: 200,
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc",
        layout: [
            { component: iro.ui.Wheel },
            { component: iro.ui.Box },
            { component: iro.ui.Slider, options: { sliderType: 'hue' } },
            { component: iro.ui.Slider, options: { sliderType: 'saturation' } },
            { component: iro.ui.Slider, options: { sliderType: 'value' } },
            // { component: iro.ui.Slider, options: { sliderType: 'alpha' } }, // Uncomment for transparency control
        ]
    });

    colorPicker.on('color:change', (color) => {
      const newColor = new paper.Color(color.hexString); // Use Paper.js color object
      // Avoid triggering mass change if color hasn't actually changed significantly
      if (!currColor || !currColor.equals(newColor)) {
            currColor = newColor;
            if (inputChangeAll.checked) {
                paths.forEach(p => {
                    // Only change pixels that are not transparent/white
                    if (p.pixel.fillColor && !p.pixel.fillColor.equals(new paper.Color('white'))) {
                         p.pixel.fillColor = currColor;
                    }
                 });
                 paperScope.view.draw(); // Redraw the view
            }
            inputColorHex.value = currColor.toCSS(true); // Use hex for input field
      }
    });

     // --- Tool Selection Logic ---
    function setActiveTool(toolName) {
        currentTool = toolName;
        currentToolDisplay.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1); // Capitalize

        // Update button styles
        document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.getElementById(`tool-${toolName}`);
        if (activeBtn) activeBtn.classList.add('active');

        // Update cursor
        canvas.classList.remove('eyedropper-cursor', 'fill-cursor');
        if (toolName === 'eyedropper') {
            canvas.classList.add('eyedropper-cursor');
        } else if (toolName === 'fill') {
             canvas.classList.add('fill-cursor');
        } else {
             // Default cursor is set in CSS, no class needed or use crosshair explicitly
             // canvas.style.cursor = 'crosshair';
        }
    }

    toolDrawBtn.addEventListener('click', () => setActiveTool('draw'));
    toolFillBtn.addEventListener('click', () => setActiveTool('fill'));
    toolEyedropperBtn.addEventListener('click', () => setActiveTool('eyedropper'));


    // --- Grid Creation Function ---
    function createGrid() {
        // Clear previous project if it exists
        if (paperScope && paperScope.project) {
            paperScope.project.clear();
        }

        // Setup new Paper.js scope for the canvas
        paperScope = new paper.PaperScope();
        paperScope.setup(canvas);
        paperScope.install(window); // Install in global scope temporarily for callbacks

        paths = []; // Reset paths array
        gridSize = parseInt(inputGridSize.value) || 8;
        cellSize = parseInt(inputCellSize.value) || 30;
        canvas.width = gridSize * cellSize;
        canvas.height = gridSize * cellSize;
        paperScope.view.viewSize = new paperScope.Size(canvas.width, canvas.height);

        for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
                const rect = new paperScope.Rectangle(
                    new paperScope.Point(i * cellSize, j * cellSize),
                    new paperScope.Size(cellSize, cellSize)
                );
                const path = new paperScope.Path.Rectangle(rect);
                path.fillColor = null; // Start transparent (or use 'white')
                path.strokeColor = showGridLines ? 'black' : null;
                path.strokeWidth = 1;

                // Store grid coordinates with the path
                path.gridX = i;
                path.gridY = j;

                // --- Mouse Event Handlers for Pixels ---
                 path.onMouseDown = function(event) {
                    event.preventDefault(); // Prevent text selection/dragging
                    isMouseDown = true;
                    handlePixelClick(this, event);
                };

                path.onMouseEnter = function(event) {
                    if (isMouseDown) {
                        handlePixelClick(this, event, true); // Pass 'true' for drag
                    }
                };

                 // Add path object to our array
                 paths.push({ x: i, y: j, pixel: path });
            }
        }

         // --- Global Mouse Up Handler ---
        paperScope.view.onMouseUp = () => {
            if (isMouseDown) {
                isMouseDown = false;
                 lastPaintedCoords = { x: -1, y: -1 }; // Reset last painted coord on mouse up
            }
        };

        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        paperScope.view.draw(); // Initial draw
    }

    // --- Pixel Interaction Logic ---
    function handlePixelClick(path, event, isDrag = false) {
        const isLeftClick = event.event.button === 0; // 0 = left, 2 = right

         // Avoid re-painting the same cell repeatedly during a single drag motion
        if (isDrag && path.gridX === lastPaintedCoords.x && path.gridY === lastPaintedCoords.y) {
             return;
         }

        switch (currentTool) {
            case 'draw':
                path.fillColor = isLeftClick ? currColor.clone() : null; // Left click draws, Right click erases (sets to null/transparent)
                break;
            case 'fill':
                if (isLeftClick) { // Only fill on left click
                     floodFill(path.gridX, path.gridY, currColor);
                }
                break;
             case 'eyedropper':
                 if (isLeftClick) { // Only pick on left click
                     const pickedColor = path.fillColor ? path.fillColor.toCSS(true) : '#ffffff'; // Default to white if null/transparent
                     colorPicker.color.hexString = pickedColor; // Update color picker
                     inputColorHex.value = pickedColor; // Update text input
                     setActiveTool('draw'); // Switch back to draw tool after picking
                 }
                 break;
        }

         lastPaintedCoords = { x: path.gridX, y: path.gridY };
         paperScope.view.draw(); // Redraw needed elements
    }

    // --- Flood Fill Implementation (BFS) ---
    function floodFill(startX, startY, newColor) {
        const targetColor = getPixelPath(startX, startY)?.pixel.fillColor;

         // If the target color is the same as the new color, do nothing
         // Handle null/undefined comparison carefully
         const newColorIsNull = !newColor || newColor.toCSS(true) === 'rgba(0,0,0,0)'; // Assuming transparent is represented by null/rgba(0,0,0,0)
         const targetColorIsNull = !targetColor || targetColor.toCSS(true) === 'rgba(0,0,0,0)';

         if (newColorIsNull && targetColorIsNull) return;
         if (!newColorIsNull && !targetColorIsNull && newColor.equals(targetColor)) return;


        const queue = [{ x: startX, y: startY }];
        const visited = new Set([`${startX},${startY}`]); // Keep track of visited pixels to avoid infinite loops

         while (queue.length > 0) {
            const { x, y } = queue.shift();
            const currentPath = getPixelPath(x, y);

             if (!currentPath) continue; // Should not happen in grid bounds

            // Color the current pixel
            currentPath.pixel.fillColor = newColor ? newColor.clone() : null;


             // Check neighbors (up, down, left, right)
            const neighbors = [
                 { nx: x, ny: y - 1 }, { nx: x, ny: y + 1 },
                 { nx: x - 1, ny: y }, { nx: x + 1, ny: y }
             ];

            for (const { nx, ny } of neighbors) {
                 const neighborKey = `${nx},${ny}`;
                 // Check bounds and if already visited
                 if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited.has(neighborKey)) {
                    const neighborPath = getPixelPath(nx, ny);
                     if (neighborPath) {
                        const neighborColor = neighborPath.pixel.fillColor;
                         const neighborColorIsNull = !neighborColor || neighborColor.toCSS(true) === 'rgba(0,0,0,0)';

                        // Check if neighbor has the target color
                         if ((targetColorIsNull && neighborColorIsNull) || (!targetColorIsNull && !neighborColorIsNull && targetColor.equals(neighborColor))) {
                            visited.add(neighborKey);
                             queue.push({ x: nx, y: ny });
                        }
                     }
                 }
             }
        }
         paperScope.view.draw(); // Redraw after fill is complete
    }


    // Helper to get path object by grid coordinates
    function getPixelPath(x, y) {
        // Since paths are stored linearly, calculate the index
        if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
            // The original loop added row by row (inner loop j=y, outer loop i=x)
            // So index is i * gridSize + j  => x * gridSize + y
            // Correction: Original loop was `for i { for j { ... paths.push({x:i, y:j}) }}`
            // This means index is `i * gridSize + j` which corresponds to `x * gridSize + y`
            const index = x * gridSize + y;
            return paths[index];
        }
        return null; // Out of bounds
    }


    // --- Button Actions ---
    btnUpdateGrid.addEventListener('click', createGrid);

    btnGenerateMatrix.addEventListener('click', () => {
        let colorsUsed = {};
        let charCode = 97; // Start labeling colors with 'a'

        // First pass: Assign characters to unique colors
        paths.forEach(p => {
            let colorStyle = p.pixel.fillColor ? p.pixel.fillColor.toCSS(true) : 'transparent'; // Use rgba format or 'transparent'

            if (colorStyle === 'rgba(0,0,0,0)' || colorStyle === 'transparent') { // Treat explicit alpha 0 and null as transparent
                colorStyle = 'transparent';
            } else if (colorStyle === 'rgb(255,255,255)') { // Treat opaque white separately? Or group with transparent? Let's use '.' for both
                 colorStyle = 'transparent'; // Group white and transparent for '.'
             }

             if (colorStyle !== 'transparent' && !colorsUsed[colorStyle]) {
                 let label = String.fromCharCode(charCode);
                 colorsUsed[colorStyle] = label;
                 charCode++;
             }
        });

         // Build the color definition part of the output
        let matrixOutput = "Color Definitions:\n";
        matrixOutput += Object.entries(colorsUsed)
            // Extract RGB from rgba(r,g,b,a) or rgb(r,g,b)
            .map(([color, label]) => `${label} = (${color.match(/\d+/g)?.slice(0, 3).join(',') || 'Error'})`)
            .join("\n");
        matrixOutput += "\n\nMatrix:\n";

        // Sort paths by row, then column for correct matrix order
        paths.sort((a, b) => a.y - b.y || a.x - b.x);

        // Build the matrix grid part of the output
        for (let j = 0; j < gridSize; j++) { // Iterate rows (y)
            let row = [];
            for (let i = 0; i < gridSize; i++) { // Iterate columns (x)
                 const index = j * gridSize + i; // Correct index calculation for row-major order
                 const p = paths[index];
                 let colorStyle = p.pixel.fillColor ? p.pixel.fillColor.toCSS(true) : 'transparent';
                 let char = '.'; // Default character for transparent/white

                 if (colorStyle === 'rgba(0,0,0,0)' || colorStyle === 'transparent' || colorStyle === 'rgb(255,255,255)') {
                     char = '.';
                 } else if (colorsUsed[colorStyle]) {
                    char = colorsUsed[colorStyle];
                 }
                row.push(char);
            }
            matrixOutput += row.join(", ") + ",\n";
        }
        matrixDiv.textContent = matrixOutput;
    });

    btnReset.addEventListener('click', () => {
        paths.forEach(p => {
            p.pixel.fillColor = null; // Reset to transparent/null
        });
        // Reset color picker to white (or another default)
        colorPicker.color.hexString = '#ffffff';
        inputColorHex.value = '#ffffff';
        currColor = new paper.Color('white');
        matrixDiv.textContent = 'Grid reset. Click "Generate Matrix" again.';
        paperScope.view.draw();
    });

    btnBlackify.addEventListener('click', () => {
        const blackColor = new paper.Color('black');
        paths.forEach(p => {
            // Fill if transparent (null) or explicitly white
            if (!p.pixel.fillColor || p.pixel.fillColor.equals(new paper.Color('white'))) {
                p.pixel.fillColor = blackColor.clone();
            }
        });
        paperScope.view.draw();
    });

     btnToggleGridlines.addEventListener('click', () => {
        showGridLines = !showGridLines;
         paths.forEach(p => {
             p.pixel.strokeColor = showGridLines ? 'black' : null;
         });
         btnToggleGridlines.textContent = showGridLines ? 'Hide Grid Lines' : 'Show Grid Lines';
          // Add icon back if needed - simple text toggle here
          btnToggleGridlines.classList.toggle('icon-grid', showGridLines); // Re-add icon class if shown
          paperScope.view.draw();
     });

    btnExportPng.addEventListener('click', () => {
        // Ensure the canvas is fully drawn before exporting
        paperScope.view.draw();

        // Temporarily disable stroke for cleaner export if grid lines are on
        const originalStrokeColors = [];
        if (showGridLines) {
            paths.forEach(p => {
                originalStrokeColors.push({ path: p.pixel, color: p.pixel.strokeColor });
                p.pixel.strokeColor = null;
            });
            paperScope.view.draw(); // Redraw without lines
        }


        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'pixel-art.png';
        link.href = dataURL;
        document.body.appendChild(link); // Required for Firefox
        link.click();
        document.body.removeChild(link);


         // Restore stroke colors if they were temporarily removed
        if (showGridLines && originalStrokeColors.length > 0) {
            originalStrokeColors.forEach(item => {
               if(item.path) item.path.strokeColor = item.color;
            });
             paperScope.view.draw(); // Redraw with lines back
        }
    });


    btnColorInputOk.addEventListener('click', () => {
        try {
            colorPicker.color.hexString = inputColorHex.value;
        } catch (e) {
            console.error("Invalid color input:", inputColorHex.value);
            alert("Invalid color format. Please use #rrggbb or a valid color name.");
        }
    });
    // Allow setting color by pressing Enter in the input field
    inputColorHex.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault(); // Prevent form submission if it were in a form
            btnColorInputOk.click(); // Trigger the OK button's action
        }
    });


    // --- Initial Setup ---
    inputGridSize.value = gridSize;
    inputCellSize.value = cellSize;
    setActiveTool('draw'); // Set initial tool
    createGrid(); // Create the initial grid

  </script>
</body>
</html>
