<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Matrix Editor</title>
  <!-- Paper.js Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
  <!-- iro.js Farbw√§hler Bibliothek -->
  <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
  <style>
    /* CSS bleibt weitgehend unver√§ndert, da es nicht die Ursache des Problems war */
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #f5f5f5;
      --border-color: #ccc;
      --text-color: #333;
      --canvas-border: #888;
      --active-tool-bg: #e0e0e0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--secondary-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      width: 100%;
      max-width: 1200px;
    }

    .controls, .canvas-container, .output-container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 280px;
    }

    .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #cv {
      border: 2px solid var(--canvas-border);
      cursor: crosshair; /* Standard-Cursor */
      margin-bottom: 15px;
       /* Verhindert das Ziehen von Bildern */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      /* WICHTIG: Verhindert Standard-Browserverhalten bei Drag-Events auf dem Canvas */
      touch-action: none;
    }

     #cv.eyedropper-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z'/><path d='M12 14l6.36-6.36'/><path d='M8.5 8.5l7 7'/></svg>") 8 8, crosshair;
    }

    #cv.fill-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black'><path d='M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 18v-6h4v6h-4z'/></svg>") 8 16, pointer; /* Farbeimer-artiger Cursor */
    }

    .control-group {
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 15px;
    }

    .control-group legend {
      font-weight: bold;
      padding: 0 5px;
      color: var(--primary-color);
    }

     .control-group label,
     .control-group button {
        margin-bottom: 8px; /* F√ºgt etwas Platz unter Labels und Buttons hinzu */
     }

    .control-group input[type="number"],
    .control-group input[type="text"] {
      width: calc(100% - 16px); /* Volle Breite minus Padding */
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-top: 4px;
    }

    .control-group input[type="checkbox"] {
        margin-right: 5px;
        vertical-align: middle;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      font-size: 1em;
      margin: 5px 2px; /* Etwas Rand hinzugef√ºgt */
      display: inline-flex; /* Richtet Icon und Text aus */
      align-items: center; /* Richtet Icon und Text aus */
      gap: 5px; /* Platz zwischen Icon und Text */
    }

    button:hover {
      background-color: #3a7ac2;
    }

    button.secondary {
        background-color: #6c757d;
    }
    button.secondary:hover {
        background-color: #5a6268;
    }

    button.danger {
        background-color: #dc3545;
    }
    button.danger:hover {
        background-color: #c82333;
    }

    button.tool-button.active {
        background-color: var(--active-tool-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }

    #color-picker-container {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    .iro__slider {
        border-radius: 4px; /* Leicht abgerundeter Slider */
    }
    .iro__marker {
        border: 2px solid white; /* Macht den Marker sichtbarer */
        box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }

    .color-input-group {
        display: flex;
        gap: 5px;
        align-items: center;
    }
     .color-input-group input[type="text"] {
        flex-grow: 1;
        margin-top: 0; /* √úberschreibt allgemeinen Rand */
        margin-bottom: 0; /* √úberschreibt allgemeinen Rand */
     }
    .color-input-group button {
        padding: 8px 10px;
        margin: 0; /* √úberschreibt allgemeinen Rand */
    }

    #matrix {
      white-space: pre;
      font-family: 'Courier New', Courier, monospace;
      background-color: #e9e9e9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid var(--border-color);
      max-height: 400px;
      overflow: auto;
      text-align: left;
      line-height: 1.4;
    }

    /* Einfache Icons mit Zeichen f√ºr Demo */
     .icon-fill::before { content: "üíß"; margin-right: 4px;}
     .icon-eyedropper::before { content: "üß™"; margin-right: 4px; }
     .icon-draw::before { content: "‚úèÔ∏è"; margin-right: 4px; }
     .icon-reset::before { content: "üîÑ"; margin-right: 4px; }
     .icon-export::before { content: "üíæ"; margin-right: 4px; }
     .icon-grid::before { content: "‚ñ¶"; margin-right: 4px; }
     .icon-done::before { content: "‚úÖ"; margin-right: 4px; }
     .icon-blackify::before { content: "‚¨õ"; margin-right: 4px; }

  </style>
</head>

<body>
  <h1>Pixel Matrix Editor</h1>

  <div class="container">

    <div class="controls">
      <fieldset class="control-group">
        <legend>Grid Settings</legend>
        <label for="grid-size">Grid Size (N x N):</label>
        <input type="number" id="grid-size" value="8" min="4" max="64">
        <label for="cell-size">Cell Size (px):</label>
        <input type="number" id="cell-size" value="30" min="5" max="50">
        <button id="update-grid">Update Grid</button>
      </fieldset>

      <fieldset class="control-group">
        <legend>Color</legend>
        <div id="color-picker-container">
          <div id="color-picker"></div>
        </div>
         <div class="color-input-group">
            <input type="text" id="color-input" placeholder="#rrggbb">
            <button id="color-input-ok" title="Set color from input">OK</button>
         </div>
        <div>
          <input type="checkbox" id="changeforall" style="vertical-align: middle;">
          <label for="changeforall">Apply to all colored pixels</label>
        </div>
      </fieldset>

       <fieldset class="control-group">
            <legend>Tools (Active: <span id="current-tool-display">Draw</span>)</legend>
            <button id="tool-draw" class="tool-button active icon-draw" title="Draw/Erase Tool (Left/Right Click)">Draw</button>
            <button id="tool-fill" class="tool-button icon-fill" title="Fill Tool">Fill</button>
            <button id="tool-eyedropper" class="tool-button icon-eyedropper" title="Eyedropper Tool">Pick Color</button>
        </fieldset>

      <fieldset class="control-group">
        <legend>Actions</legend>
        <button id="done" class="icon-done">Generate Matrix</button>
        <button id="reset" class="secondary icon-reset">Reset Grid</button>
        <button id="blackify" class="secondary icon-blackify">Fill Blank with Black</button>
         <button id="toggle-gridlines" class="secondary icon-grid">Toggle Grid Lines</button>
        <button id="export-png" class="icon-export">Export as PNG</button>
      </fieldset>
    </div>

    <div class="canvas-container">
      <canvas id="cv"></canvas>
      <!-- Canvas-Gr√∂√üe wird dynamisch durch JS gesetzt -->
    </div>

    <div class="output-container">
      <h2>Matrix Output</h2>
      <div id="matrix">Click "Generate Matrix" to see the output here.</div>
    </div>

  </div>

  <script>
    // Warten, bis das DOM vollst√§ndig geladen ist
    document.addEventListener('DOMContentLoaded', () => {

        const canvas = document.getElementById("cv");
        // HINWEIS: Wir verwenden hier nicht mehr `canvas.getContext('2d')`, da Paper.js das Canvas-Management √ºbernimmt.
        // F√ºr den PNG-Export greifen wir sp√§ter direkt auf das von Paper.js verwaltete Canvas zu.
        const matrixDiv = document.getElementById("matrix");

        // --- Steuerelemente ---
        const btnGenerateMatrix = document.getElementById("done");
        const btnReset = document.getElementById("reset");
        const btnBlackify = document.getElementById("blackify");
        const btnExportPng = document.getElementById("export-png");
        const btnUpdateGrid = document.getElementById("update-grid");
        const btnToggleGridlines = document.getElementById("toggle-gridlines");
        const inputGridSize = document.getElementById("grid-size");
        const inputCellSize = document.getElementById("cell-size");
        const inputChangeAll = document.getElementById("changeforall");
        const inputColorHex = document.getElementById("color-input");
        const btnColorInputOk = document.getElementById("color-input-ok");
        const toolDrawBtn = document.getElementById('tool-draw');
        const toolFillBtn = document.getElementById('tool-fill');
        const toolEyedropperBtn = document.getElementById('tool-eyedropper');
        const currentToolDisplay = document.getElementById('current-tool-display');
        const colorPickerContainer = document.getElementById('color-picker');

        // --- Zustandsvariablen ---
        let paperScope; // H√§lt den Paper.js-Scope
        let paths = []; // Speichert Pfadobjekte {x, y, pixel}
        let gridSize = 8;
        let cellSize = 30;
        // KORREKTUR: Initialisierung von currColor innerhalb des Scopes nach Paper.js Setup
        let currColor; // = new paperScope.Color('white'); // Wird in createGrid initialisiert
        let isMouseDown = false;
        let lastPaintedCoords = { x: -1, y: -1 }; // F√ºr fl√ºssigeres Ziehen
        let showGridLines = true;
        let currentTool = 'draw'; // 'draw', 'fill', 'eyedropper'

        // --- Farbw√§hler Setup ---
        const colorPicker = new iro.ColorPicker(colorPickerContainer, {
            width: 200,
            color: "#ffffff", // Startet mit Wei√ü
            borderWidth: 1,
            borderColor: "#ccc",
            layout: [
                { component: iro.ui.Wheel },
                { component: iro.ui.Box },
                { component: iro.ui.Slider, options: { sliderType: 'hue' } },
                { component: iro.ui.Slider, options: { sliderType: 'saturation' } },
                { component: iro.ui.Slider, options: { sliderType: 'value' } },
                // { component: iro.ui.Slider, options: { sliderType: 'alpha' } }, // Einkommentieren f√ºr Transparenzsteuerung
            ]
        });

        // --- Event Listener f√ºr Farbw√§hler ---
        colorPicker.on('color:change', (color) => {
          // Stelle sicher, dass paperScope initialisiert ist
          if (!paperScope) return;

          // KORREKTUR: Verwende paperScope.Color f√ºr die Konvertierung
          const newColor = new paperScope.Color(color.hexString);

          // KORREKTUR: Die Logik zur Aktualisierung von currColor muss sicherstellen,
          // dass die Variable *immer* aktualisiert wird, wenn sich die Farbe √§ndert,
          // unabh√§ngig von der Checkbox 'changeforall'.
          // Die Pr√ºfung `!currColor.equals(newColor)` verhindert unn√∂tige Updates bei minimalen √Ñnderungen.
          if (!currColor || !currColor.equals(newColor)) {
                // console.log("Updating currColor to:", newColor.toCSS(true)); // Debugging
                currColor = newColor; // <<<< WICHTIG: Aktualisiere die globale Farbvariable

                // Wende die Farbe auf alle an, wenn die Checkbox aktiviert ist
                if (inputChangeAll.checked) {
                    const whiteColor = new paperScope.Color('white'); // Referenzfarbe f√ºr Vergleich
                    paths.forEach(p => {
                        // √Ñndere nur Pixel, die nicht transparent/wei√ü sind
                        if (p.pixel.fillColor && !p.pixel.fillColor.equals(whiteColor)) {
                             // KORREKTUR: Verwende clone(), um sicherzustellen, dass jedes Pixel sein eigenes Farbobjekt bekommt
                             p.pixel.fillColor = currColor.clone();
                        }
                     });
                     paperScope.view.draw(); // Zeichne die Ansicht neu
                }
                // Aktualisiere immer das Textfeld, auch wenn 'changeforall' nicht aktiv ist
                inputColorHex.value = currColor.toCSS(true); // Verwende Hex f√ºr das Eingabefeld
          }
        });

        // --- Werkzeugauswahl-Logik ---
        function setActiveTool(toolName) {
            currentTool = toolName;
            // KORREKTUR: Tool-Name korrekt anzeigen (Gro√übuchstabe am Anfang)
            currentToolDisplay.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);

            // Aktualisiere Button-Stile
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`tool-${toolName}`);
            if (activeBtn) activeBtn.classList.add('active');

            // Aktualisiere Cursor
            canvas.classList.remove('eyedropper-cursor', 'fill-cursor');
            if (toolName === 'eyedropper') {
                canvas.classList.add('eyedropper-cursor');
            } else if (toolName === 'fill') {
                 canvas.classList.add('fill-cursor');
            } else {
                 // Standard-Cursor (crosshair) wird durch CSS gesetzt, keine Klasse n√∂tig
                 // canvas.style.cursor = 'crosshair'; // Explizites Setzen w√§re auch m√∂glich
            }
        }

        toolDrawBtn.addEventListener('click', () => setActiveTool('draw'));
        toolFillBtn.addEventListener('click', () => setActiveTool('fill'));
        toolEyedropperBtn.addEventListener('click', () => setActiveTool('eyedropper'));


        // --- Grid-Erstellungsfunktion ---
        function createGrid() {
            // L√∂sche vorheriges Projekt, falls vorhanden
            if (paperScope && paperScope.project) {
                paperScope.project.clear();
            }

            // Richte neuen Paper.js-Scope f√ºr das Canvas ein
            // KORREKTUR: Vermeide `paperScope.install(window)` wenn m√∂glich.
            // Greife stattdessen explizit √ºber `paperScope.` auf Paper.js-Objekte zu.
            paperScope = new paper.PaperScope();
            paperScope.setup(canvas);
            // paperScope.install(window); // NICHT EMPFOHLEN

            // KORREKTUR: Initialisiere currColor *nachdem* paperScope eingerichtet wurde
            currColor = new paperScope.Color('white');
            // Synchronisiere Farbw√§hler mit der initialen Farbe (obwohl er schon auf wei√ü starten sollte)
            colorPicker.color.hexString = currColor.toCSS(true);
            inputColorHex.value = currColor.toCSS(true);


            paths = []; // Setze Pfad-Array zur√ºck
            gridSize = parseInt(inputGridSize.value) || 8;
            cellSize = parseInt(inputCellSize.value) || 30;
            const totalSize = gridSize * cellSize;
            canvas.width = totalSize;
            canvas.height = totalSize;
            paperScope.view.viewSize = new paperScope.Size(totalSize, totalSize);

            // Erstelle das Grid mit Rechtecken
            for (let i = 0; i < gridSize; i++) { // x-Koordinate
                for (let j = 0; j < gridSize; j++) { // y-Koordinate
                    // KORREKTUR: Verwende paperScope zum Erstellen von Objekten
                    const rect = new paperScope.Rectangle(
                        new paperScope.Point(i * cellSize, j * cellSize),
                        new paperScope.Size(cellSize, cellSize)
                    );
                    const path = new paperScope.Path.Rectangle(rect);
                    path.fillColor = null; // Starte transparent (null)
                    path.strokeColor = showGridLines ? new paperScope.Color('black') : null; // Verwende paperScope.Color oder null
                    path.strokeWidth = 1;

                    // Speichere Grid-Koordinaten mit dem Pfad
                    path.gridX = i;
                    path.gridY = j;

                    // --- Maus-Event-Handler f√ºr Pixel ---
                    path.onMouseDown = function(event) {
                        event.preventDefault(); // Verhindert Textauswahl/Ziehen
                        isMouseDown = true;
                        handlePixelClick(this, event);
                    };

                    path.onMouseEnter = function(event) {
                        if (isMouseDown) {
                            handlePixelClick(this, event, true); // √úbergebe 'true' f√ºr Ziehen (Drag)
                        }
                    };

                     // F√ºge Pfadobjekt zu unserem Array hinzu
                     // KORREKTUR: Stelle sicher, dass die Reihenfolge konsistent ist (x dann y)
                     paths.push({ x: i, y: j, pixel: path });
                }
            }

             // --- Globaler Mouse-Up-Handler ---
            paperScope.view.onMouseUp = () => {
                if (isMouseDown) {
                    isMouseDown = false;
                     lastPaintedCoords = { x: -1, y: -1 }; // Setze letzte gemalte Koordinate bei Mouse Up zur√ºck
                }
            };

             // --- Globaler Mouse-Leave-Handler (f√ºr den Fall, dass man das Canvas beim Ziehen verl√§sst) ---
             paperScope.view.onMouseLeave = () => {
                 if (isMouseDown) {
                     isMouseDown = false;
                     lastPaintedCoords = { x: -1, y: -1 };
                 }
             };

            // Verhindere Kontextmen√º bei Rechtsklick auf dem Canvas
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            paperScope.view.draw(); // Initiales Zeichnen
            console.log("Grid created with size", gridSize, "and cell size", cellSize); // Debugging
        }

        // --- Pixel-Interaktionslogik ---
        function handlePixelClick(path, event, isDrag = false) {
            // KORREKTUR: event.event ist bei Paper.js korrekt, um auf das native Browser-Event zuzugreifen
            const isLeftClick = event.event.button === 0; // 0 = links, 1 = mitte, 2 = rechts
            const isRightClick = event.event.button === 2;

             // Vermeide wiederholtes Malen derselben Zelle w√§hrend einer einzelnen Ziehbewegung
             // KORREKTUR: Pr√ºfe nur wenn isDrag true ist
             if (isDrag && path.gridX === lastPaintedCoords.x && path.gridY === lastPaintedCoords.y) {
                 return;
             }

             //console.log(`Click Tool: ${currentTool}, Color: ${currColor?.toCSS(true)}, LeftClick: ${isLeftClick}, RightClick: ${isRightClick}`); // Debugging

            switch (currentTool) {
                case 'draw':
                    // KORREKTUR: Verwende .clone() f√ºr die Farbe, um Objekt-Referenzprobleme zu vermeiden.
                    // Setze auf null (transparent) bei Rechtsklick zum Radieren.
                    path.fillColor = isLeftClick ? currColor.clone() : (isRightClick ? null : path.fillColor); // Nur bei Links-/Rechtsklick √§ndern
                    break;
                case 'fill':
                    if (isLeftClick) { // F√ºlle nur bei Linksklick
                         floodFill(path.gridX, path.gridY, currColor);
                    }
                    break;
                 case 'eyedropper':
                     if (isLeftClick) { // W√§hle Farbe nur bei Linksklick
                         // KORREKTUR: Sicherer Zugriff auf fillColor und Umwandlung in Hex
                         const pickedColor = path.fillColor ? path.fillColor.toCSS(true) : '#ffffff'; // Standardm√§√üig wei√ü, wenn transparent/null
                         colorPicker.color.hexString = pickedColor; // Aktualisiere Farbw√§hler
                         inputColorHex.value = pickedColor; // Aktualisiere Textfeld
                         // KORREKTUR: Setze currColor auch direkt, da color:change eventuell nicht triggert, wenn die Farbe gleich bleibt
                         currColor = new paperScope.Color(pickedColor);
                         setActiveTool('draw'); // Wechsle nach dem Aufnehmen zur√ºck zum Zeichenwerkzeug
                     }
                     break;
            }

             // Aktualisiere letzte gemalte Koordinaten nur, wenn tats√§chlich gemalt wurde (im Draw-Modus oder Fill)
             if (currentTool === 'draw' || (currentTool === 'fill' && isLeftClick)) {
                 lastPaintedCoords = { x: path.gridX, y: path.gridY };
             }

             // KORREKTUR: Neuzeichnen ist nach jeder Interaktion sinnvoll
             paperScope.view.draw();
        }

        // --- Flood Fill Implementierung (BFS - Breitensuche) ---
        function floodFill(startX, startY, newColor) {
            if (!paperScope) return; // Sicherstellen, dass PaperScope existiert

            const targetPath = getPixelPath(startX, startY);
            if (!targetPath) return; // Sollte innerhalb des Grids nicht passieren

            const targetColor = targetPath.pixel.fillColor; // Kann null sein

            // KORREKTUR: Robuster Vergleich von Farben, auch mit null (transparent)
            const isNewColorNull = !newColor; // Ist die neue Farbe null?
            const isTargetColorNull = !targetColor; // Ist die Zielfarbe null?

            // Fall 1: Beide Farben sind null (transparent) -> nichts tun
            if (isNewColorNull && isTargetColorNull) return;
            // Fall 2: Beide Farben sind NICHT null und gleich -> nichts tun
            if (!isNewColorNull && !isTargetColorNull && newColor.equals(targetColor)) return;
            // Fall 3: Eine ist null, die andere nicht, oder beide sind nicht null, aber ungleich -> F√ºllen!

            const queue = [{ x: startX, y: startY }];
            const visited = new Set([`${startX},${startY}`]); // Verhindert Endlosschleifen

             while (queue.length > 0) {
                const { x, y } = queue.shift();
                const currentPathObj = getPixelPath(x, y);

                 if (!currentPathObj) continue; // Sicherheitscheck

                // F√§rbe das aktuelle Pixel
                // KORREKTUR: Verwende clone() oder null
                currentPathObj.pixel.fillColor = newColor ? newColor.clone() : null;

                 // Pr√ºfe Nachbarn (oben, unten, links, rechts)
                const neighbors = [
                     { nx: x, ny: y - 1 }, { nx: x, ny: y + 1 },
                     { nx: x - 1, ny: y }, { nx: x + 1, ny: y }
                 ];

                for (const { nx, ny } of neighbors) {
                     const neighborKey = `${nx},${ny}`;
                     // Pr√ºfe Grenzen und ob schon besucht
                     if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited.has(neighborKey)) {
                        const neighborPathObj = getPixelPath(nx, ny);
                         if (neighborPathObj) {
                            const neighborColor = neighborPathObj.pixel.fillColor;
                            const isNeighborColorNull = !neighborColor;

                            // Pr√ºfe, ob die Nachbarfarbe der urspr√ºnglichen Zielfarbe entspricht
                            let match = false;
                            if (isTargetColorNull && isNeighborColorNull) { // Beide transparent
                                match = true;
                            } else if (!isTargetColorNull && !isNeighborColorNull && targetColor.equals(neighborColor)) { // Beide nicht-transparent und gleich
                                match = true;
                            }

                            if (match) {
                                visited.add(neighborKey);
                                queue.push({ x: nx, y: ny });
                            }
                         }
                     }
                 }
            }
             paperScope.view.draw(); // Neuzeichnen nach Abschluss des F√ºllens
        }

        // Hilfsfunktion zum Abrufen des Pfadobjekts anhand der Grid-Koordinaten
        function getPixelPath(x, y) {
            // KORREKTUR: Indexberechnung basiert darauf, wie die Pfade im `createGrid` hinzugef√ºgt wurden.
            // √Ñu√üere Schleife war `i` (x), innere Schleife war `j` (y).
            // Der Index f√ºr (x, y) ist daher `x * gridSize + y`.
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                const index = x * gridSize + y;
                if (index < paths.length) {
                  return paths[index];
                }
            }
            // console.warn(`getPixelPath: Koordinaten (${x}, ${y}) au√üerhalb des g√ºltigen Bereichs oder Indexproblem.`);
            return null; // Au√üerhalb der Grenzen oder Fehler
        }

        // --- Button-Aktionen ---
        btnUpdateGrid.addEventListener('click', createGrid);

        btnGenerateMatrix.addEventListener('click', () => {
            if (!paperScope) return; // Sicherstellen, dass PaperScope existiert

            let colorsUsed = {};
            let charCode = 97; // Startet die Farbcodierung mit 'a'
            const transparentColorString = 'transparent'; // Eindeutiger Bezeichner f√ºr Transparenz/Wei√ü
            const whiteColor = new paperScope.Color('white');

            // Erster Durchlauf: Weise den einzigartigen Farben Zeichen zu
            paths.forEach(p => {
                let colorStyle;
                if (!p.pixel.fillColor || p.pixel.fillColor.equals(whiteColor)) {
                    colorStyle = transparentColorString; // Behandle null und Wei√ü als transparent
                } else {
                    colorStyle = p.pixel.fillColor.toCSS(true); // Nutze rgba oder rgb Format
                }

                 if (colorStyle !== transparentColorString && !(colorStyle in colorsUsed)) {
                     let label = String.fromCharCode(charCode);
                     // √úberspringe problematische Zeichen falls n√∂tig (hier nicht implementiert)
                     colorsUsed[colorStyle] = label;
                     charCode++;
                 }
            });

             // Erstelle den Farbdefinitions-Teil der Ausgabe
            let matrixOutput = "Color Definitions:\n";
            // KORREKTUR: Extrahiere RGB korrekt aus rgba(r,g,b,a) oder rgb(r,g,b)
            matrixOutput += Object.entries(colorsUsed)
                .map(([color, label]) => {
                    const match = color.match(/(\d+),\s*(\d+),\s*(\d+)/); // Extrahiert r,g,b
                    const rgb = match ? `${match[1]},${match[2]},${match[3]}` : 'Error';
                    return `${label} = (${rgb})`;
                })
                .join("\n");
            matrixOutput += "\n\nMatrix:\n";

            // KORREKTUR: Stelle sicher, dass die Matrix korrekt gelesen wird (Reihe f√ºr Reihe)
            // `paths` ist bereits in der Reihenfolge [ (0,0), (0,1), ..., (0,N-1), (1,0), ... ] gespeichert.
            // Wir m√ºssen also Reihe f√ºr Reihe (y) iterieren und f√ºr jede Reihe die Spalten (x) durchgehen.
            for (let j = 0; j < gridSize; j++) { // Iteriere √ºber Reihen (y)
                let row = [];
                for (let i = 0; i < gridSize; i++) { // Iteriere √ºber Spalten (x)
                     // KORREKTUR: Korrekten Pfad f√ºr (i, j) bzw. (x, y) holen
                     const p = getPixelPath(i, j); // Hole Pixel an (x=i, y=j)
                     if (!p) {
                         row.push('?'); // Fehlerzeichen, falls Pfad nicht gefunden wird
                         continue;
                     }

                     let char = '.'; // Standardzeichen f√ºr transparent/wei√ü
                     let colorStyle;
                     if (!p.pixel.fillColor || p.pixel.fillColor.equals(whiteColor)) {
                         colorStyle = transparentColorString;
                     } else {
                         colorStyle = p.pixel.fillColor.toCSS(true);
                     }

                     if (colorStyle !== transparentColorString) {
                        char = colorsUsed[colorStyle] || '?'; // Verwende zugewiesenes Zeichen oder '?' bei Fehler
                     }
                    row.push(char);
                }
                // F√ºge Komma am Ende jeder Zeile hinzu, au√üer der letzten (optional, aber √ºblich)
                matrixOutput += row.join(", ") + (j < gridSize - 1 ? "," : "") + "\n";
            }
            matrixDiv.textContent = matrixOutput;
        });

        btnReset.addEventListener('click', () => {
            if (!paperScope) return;
            const whiteColor = new paperScope.Color('white');
            paths.forEach(p => {
                p.pixel.fillColor = null; // Setze auf transparent/null zur√ºck
            });
            // Setze Farbw√§hler auf Wei√ü zur√ºck
            colorPicker.color.hexString = '#ffffff';
            inputColorHex.value = '#ffffff';
            currColor = whiteColor; // Setze aktuelle Farbe auf Wei√ü zur√ºck
            matrixDiv.textContent = 'Grid reset. Click "Generate Matrix" again.';
            paperScope.view.draw();
        });

        btnBlackify.addEventListener('click', () => {
            if (!paperScope) return;
            const blackColor = new paperScope.Color('black');
            const whiteColor = new paperScope.Color('white');
            paths.forEach(p => {
                // F√ºlle, wenn transparent (null) oder explizit wei√ü
                if (!p.pixel.fillColor || p.pixel.fillColor.equals(whiteColor)) {
                    p.pixel.fillColor = blackColor.clone(); // Klonen!
                }
            });
            paperScope.view.draw();
        });

         btnToggleGridlines.addEventListener('click', () => {
             if (!paperScope) return;
             showGridLines = !showGridLines;
             const stroke = showGridLines ? new paperScope.Color('black') : null;
             paths.forEach(p => {
                 p.pixel.strokeColor = stroke;
             });
             // KORREKTUR: Button-Text und Icon korrekt aktualisieren
             btnToggleGridlines.childNodes[1].nodeValue = showGridLines ? ' Hide Grid Lines' : ' Show Grid Lines'; // √Ñndert nur den Textknoten
             // F√ºge Icon-Klasse hinzu/entferne sie basierend auf dem Status
             btnToggleGridlines.classList.toggle('icon-grid', showGridLines); // Icon anzeigen/verstecken (oder CSS anpassen)

             paperScope.view.draw();
         });

        btnExportPng.addEventListener('click', () => {
            if (!paperScope) return;
            // Stelle sicher, dass das Canvas vollst√§ndig gezeichnet ist
            paperScope.view.draw();

            // Tempor√§r Striche entfernen f√ºr sauberen Export, falls Gitterlinien an sind
            const originalStrokeSettings = [];
            if (showGridLines) {
                paths.forEach(p => {
                    originalStrokeSettings.push({ path: p.pixel, strokeColor: p.pixel.strokeColor, strokeWidth: p.pixel.strokeWidth });
                    p.pixel.strokeColor = null; // Keine Kontur f√ºr den Export
                });
                paperScope.view.draw(); // Neuzeichnen ohne Linien
            }

            // KORREKTUR: Greife auf das Canvas-Element zu, das von Paper.js verwaltet wird
            const canvasElement = paperScope.view.element;
            const dataURL = canvasElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'pixel-art.png';
            link.href = dataURL;
            document.body.appendChild(link); // N√∂tig f√ºr Firefox
            link.click();
            document.body.removeChild(link);

             // Stelle Strichfarben wieder her, falls sie tempor√§r entfernt wurden
            if (showGridLines && originalStrokeSettings.length > 0) {
                originalStrokeSettings.forEach(item => {
                   if(item.path) {
                       item.path.strokeColor = item.strokeColor;
                       item.path.strokeWidth = item.strokeWidth;
                   }
                });
                 paperScope.view.draw(); // Neuzeichnen mit wiederhergestellten Linien
            }
        });

        btnColorInputOk.addEventListener('click', () => {
            if (!paperScope) return;
            try {
                // Pr√ºfe, ob die Eingabe ein g√ºltiger Hex-Code ist (vereinfachte Pr√ºfung)
                const hexValue = inputColorHex.value.trim();
                if (/^#([0-9A-F]{3}){1,2}$/i.test(hexValue)) {
                   colorPicker.color.hexString = hexValue;
                   // WICHTIG: Da color:change evtl. nicht feuert, wenn die Farbe gleich bleibt,
                   // setzen wir currColor hier manuell, um Konsistenz sicherzustellen.
                   currColor = new paperScope.Color(hexValue);
                } else {
                    throw new Error("Invalid hex format");
                }
            } catch (e) {
                console.error("Invalid color input:", inputColorHex.value, e);
                alert("Invalid color format. Please use #rrggbb or #rgb.");
            }
        });
        // Erlaube das Setzen der Farbe durch Dr√ºcken von Enter im Eingabefeld
        inputColorHex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Verhindert Formular-Submit, falls vorhanden
                btnColorInputOk.click(); // L√∂st die Aktion des OK-Buttons aus
            }
        });

        // --- Initiales Setup ---
        inputGridSize.value = gridSize;
        inputCellSize.value = cellSize;
        setActiveTool('draw'); // Setze initiales Werkzeug
        createGrid(); // Erstelle das initiale Grid
        console.log("Initial setup complete. PaperScope:", paperScope); // Debugging
    });
  </script>
</body>
</html>
