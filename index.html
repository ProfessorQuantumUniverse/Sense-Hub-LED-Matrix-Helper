<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Matrix Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
  <style>
    /* CSS bleibt unver√§ndert - siehe vorherige Antwort */
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #f5f5f5;
      --border-color: #ccc;
      --text-color: #333;
      --canvas-border: #888;
      --active-tool-bg: #e0e0e0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--secondary-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      width: 100%;
      max-width: 1200px;
    }

    .controls, .canvas-container, .output-container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 280px;
    }

    .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #cv {
      border: 2px solid var(--canvas-border);
      cursor: crosshair; /* Standard-Cursor */
      margin-bottom: 15px;
       /* Verhindert das Ziehen von Bildern */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      /* WICHTIG: Verhindert Standard-Browserverhalten bei Drag-Events auf dem Canvas */
      touch-action: none;
    }

     #cv.eyedropper-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z'/><path d='M12 14l6.36-6.36'/><path d='M8.5 8.5l7 7'/></svg>") 8 8, crosshair;
    }

    #cv.fill-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black'><path d='M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 18v-6h4v6h-4z'/></svg>") 8 16, pointer; /* Farbeimer-artiger Cursor */
    }

    .control-group {
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 15px;
    }

    .control-group legend {
      font-weight: bold;
      padding: 0 5px;
      color: var(--primary-color);
    }

     .control-group label,
     .control-group button {
        margin-bottom: 8px; /* F√ºgt etwas Platz unter Labels und Buttons hinzu */
     }

    .control-group input[type="number"],
    .control-group input[type="text"] {
      width: calc(100% - 16px); /* Volle Breite minus Padding */
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-top: 4px;
    }

    .control-group input[type="checkbox"] {
        margin-right: 5px;
        vertical-align: middle;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      font-size: 1em;
      margin: 5px 2px; /* Etwas Rand hinzugef√ºgt */
      display: inline-flex; /* Richtet Icon und Text aus */
      align-items: center; /* Richtet Icon und Text aus */
      gap: 5px; /* Platz zwischen Icon und Text */
    }

    button:hover {
      background-color: #3a7ac2;
    }

    button.secondary {
        background-color: #6c757d;
    }
    button.secondary:hover {
        background-color: #5a6268;
    }

    button.danger {
        background-color: #dc3545;
    }
    button.danger:hover {
        background-color: #c82333;
    }

    button.tool-button.active {
        background-color: var(--active-tool-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }

    #color-picker-container {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    .iro__slider {
        border-radius: 4px; /* Leicht abgerundeter Slider */
    }
    .iro__marker {
        border: 2px solid white; /* Macht den Marker sichtbarer */
        box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }

    .color-input-group {
        display: flex;
        gap: 5px;
        align-items: center;
    }
     .color-input-group input[type="text"] {
        flex-grow: 1;
        margin-top: 0; /* √úberschreibt allgemeinen Rand */
        margin-bottom: 0; /* √úberschreibt allgemeinen Rand */
     }
    .color-input-group button {
        padding: 8px 10px;
        margin: 0; /* √úberschreibt allgemeinen Rand */
    }

    #matrix {
      white-space: pre;
      font-family: 'Courier New', Courier, monospace;
      background-color: #e9e9e9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid var(--border-color);
      max-height: 400px;
      overflow: auto;
      text-align: left;
      line-height: 1.4;
    }

    /* Einfache Icons mit Zeichen f√ºr Demo */
     .icon-fill::before { content: "üíß"; margin-right: 4px;}
     .icon-eyedropper::before { content: "üß™"; margin-right: 4px; }
     .icon-draw::before { content: "‚úèÔ∏è"; margin-right: 4px; }
     .icon-reset::before { content: "üîÑ"; margin-right: 4px; }
     .icon-export::before { content: "üíæ"; margin-right: 4px; }
     .icon-grid::before { content: "‚ñ¶"; margin-right: 4px; }
     .icon-done::before { content: "‚úÖ"; margin-right: 4px; }
     .icon-blackify::before { content: "‚¨õ"; margin-right: 4px; }
  </style>
</head>

<body>
  <h1>Pixel Matrix Editor</h1>

  <div class="container">

    <div class="controls">
      <fieldset class="control-group">
        <legend>Grid Settings</legend>
        <label for="grid-size">Grid Size (N x N):</label>
        <input type="number" id="grid-size" value="8" min="4" max="64">
        <label for="cell-size">Cell Size (px):</label>
        <input type="number" id="cell-size" value="30" min="5" max="50">
        <button id="update-grid">Update Grid</button>
      </fieldset>

      <fieldset class="control-group">
        <legend>Color</legend>
        <div id="color-picker-container">
          <div id="color-picker"></div>
        </div>
         <div class="color-input-group">
            <input type="text" id="color-input" placeholder="#rrggbb">
            <button id="color-input-ok" title="Set color from input">OK</button>
         </div>
        <div>
          <input type="checkbox" id="changeforall" style="vertical-align: middle;">
          <label for="changeforall">Apply to all non-white/transparent pixels</label> <!-- Kl√§rung -->
        </div>
      </fieldset>

       <fieldset class="control-group">
            <legend>Tools (Active: <span id="current-tool-display">Draw</span>)</legend>
            <button id="tool-draw" class="tool-button active icon-draw" title="Draw/Erase Tool (Left/Right Click)">Draw</button>
            <button id="tool-fill" class="tool-button icon-fill" title="Fill Tool">Fill</button>
            <button id="tool-eyedropper" class="tool-button icon-eyedropper" title="Eyedropper Tool">Pick Color</button>
        </fieldset>

      <fieldset class="control-group">
        <legend>Actions</legend>
        <button id="done" class="icon-done">Generate Matrix</button>
        <button id="reset" class="secondary icon-reset">Reset Grid</button>
        <button id="blackify" class="secondary icon-blackify">Fill Blank with Black</button>
         <button id="toggle-gridlines" class="secondary icon-grid">Toggle Grid Lines</button>
        <button id="export-png" class="icon-export">Export as PNG</button>
      </fieldset>
    </div>

    <div class="canvas-container">
      <canvas id="cv"></canvas>
    </div>

    <div class="output-container">
      <h2>Matrix Output</h2>
      <div id="matrix">Click "Generate Matrix" to see the output here.</div>
    </div>

  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {

        const canvas = document.getElementById("cv");
        const matrixDiv = document.getElementById("matrix");
        const btnGenerateMatrix = document.getElementById("done");
        const btnReset = document.getElementById("reset");
        const btnBlackify = document.getElementById("blackify");
        const btnExportPng = document.getElementById("export-png");
        const btnUpdateGrid = document.getElementById("update-grid");
        const btnToggleGridlines = document.getElementById("toggle-gridlines");
        const inputGridSize = document.getElementById("grid-size");
        const inputCellSize = document.getElementById("cell-size");
        const inputChangeAll = document.getElementById("changeforall");
        const inputColorHex = document.getElementById("color-input");
        const btnColorInputOk = document.getElementById("color-input-ok");
        const toolDrawBtn = document.getElementById('tool-draw');
        const toolFillBtn = document.getElementById('tool-fill');
        const toolEyedropperBtn = document.getElementById('tool-eyedropper');
        const currentToolDisplay = document.getElementById('current-tool-display');
        const colorPickerContainer = document.getElementById('color-picker');

        let paperScope;
        let paths = [];
        let gridSize = 8;
        let cellSize = 30;
        let currColor; // Wird in createGrid initialisiert
        let isMouseDown = false;
        let lastPaintedCoords = { x: -1, y: -1 };
        let showGridLines = true;
        let currentTool = 'draw';
        let whiteColor; // Wird in createGrid initialisiert f√ºr Vergleiche
        let blackColor; // Wird in createGrid initialisiert

        // Konstante f√ºr den Schl√ºssel von transparenten/wei√üen Pixeln im Mapping
        const TRANSPARENT_KEY = '__TRANSPARENT__';

        const colorPicker = new iro.ColorPicker(colorPickerContainer, {
            width: 200,
            color: "#ffffff",
            borderWidth: 1,
            borderColor: "#ccc",
            layout: [
                { component: iro.ui.Wheel },
                { component: iro.ui.Box },
                { component: iro.ui.Slider, options: { sliderType: 'hue' } },
                { component: iro.ui.Slider, options: { sliderType: 'saturation' } },
                { component: iro.ui.Slider, options: { sliderType: 'value' } },
            ]
        });

        colorPicker.on('color:change', (color) => {
          if (!paperScope) return;
          const newColor = new paperScope.Color(color.hexString);

          if (!currColor || !currColor.equals(newColor)) {
                // console.log("Color changed via picker. Old:", currColor?.toCSS(), "New:", newColor.toCSS());
                currColor = newColor; // Globale Farbe aktualisieren
                inputColorHex.value = currColor.toHex(); // Hex im Inputfeld bevorzugen

                if (inputChangeAll.checked && paths.length > 0) {
                    // console.log("Applying color change to all non-white pixels");
                    paths.forEach(p => {
                        // √Ñndere nur Pixel, die NICHT null (transparent) UND NICHT wei√ü sind
                        if (p.pixel.fillColor && !p.pixel.fillColor.equals(whiteColor)) {
                             p.pixel.fillColor = currColor.clone();
                        }
                     });
                     paperScope.view.draw();
                }
          }
        });

        function setActiveTool(toolName) {
            currentTool = toolName;
            currentToolDisplay.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`tool-${toolName}`);
            if (activeBtn) activeBtn.classList.add('active');

            canvas.classList.remove('eyedropper-cursor', 'fill-cursor');
            if (toolName === 'eyedropper') canvas.classList.add('eyedropper-cursor');
            else if (toolName === 'fill') canvas.classList.add('fill-cursor');
            // else Standard (crosshair via CSS)
            // console.log("Active tool:", currentTool);
        }

        toolDrawBtn.addEventListener('click', () => setActiveTool('draw'));
        toolFillBtn.addEventListener('click', () => setActiveTool('fill'));
        toolEyedropperBtn.addEventListener('click', () => setActiveTool('eyedropper'));

        function createGrid() {
            if (paperScope && paperScope.project) {
                paperScope.project.clear();
            }

            paperScope = new paper.PaperScope();
            paperScope.setup(canvas);

            // Initialisiere Farben nach paperScope Setup
            whiteColor = new paperScope.Color('white');
            blackColor = new paperScope.Color('black');
            // Setze Startfarbe und synchronisiere Picker und Input
            currColor = new paperScope.Color(colorPicker.color.hexString);
            inputColorHex.value = currColor.toHex();

            paths = [];
            gridSize = parseInt(inputGridSize.value) || 8;
            cellSize = parseInt(inputCellSize.value) || 30;
            const totalSize = gridSize * cellSize;
            canvas.width = totalSize;
            canvas.height = totalSize;
            paperScope.view.viewSize = new paperScope.Size(totalSize, totalSize);

            const strokeColor = showGridLines ? blackColor : null;

            for (let i = 0; i < gridSize; i++) { // Spalte (x)
                for (let j = 0; j < gridSize; j++) { // Reihe (y)
                    const rect = new paperScope.Rectangle(i * cellSize, j * cellSize, cellSize, cellSize);
                    const path = new paperScope.Path.Rectangle(rect);
                    path.fillColor = null; // <<< Wichtig: Start als null (transparent)
                    path.strokeColor = strokeColor ? strokeColor.clone() : null; // Klonen oder null
                    path.strokeWidth = 1;
                    path.gridX = i;
                    path.gridY = j;

                    path.onMouseDown = function(event) {
                        event.preventDefault();
                        isMouseDown = true;
                        handlePixelClick(this, event);
                    };
                    path.onMouseEnter = function(event) {
                        if (isMouseDown) {
                            handlePixelClick(this, event, true);
                        }
                    };
                    // Korrekte Reihenfolge f√ºr Index: x * gridSize + y
                    paths[i * gridSize + j] = { x: i, y: j, pixel: path };
                }
            }

            paperScope.view.onMouseUp = () => {
                if (isMouseDown) {
                    isMouseDown = false;
                    lastPaintedCoords = { x: -1, y: -1 };
                }
            };
            paperScope.view.onMouseLeave = () => { // Verhindert "h√§ngendes" Malen
                 if (isMouseDown) {
                     isMouseDown = false;
                     lastPaintedCoords = { x: -1, y: -1 };
                 }
             };

            canvas.addEventListener('contextmenu', e => e.preventDefault());
            paperScope.view.draw();
            console.log(`Grid created: ${gridSize}x${gridSize}, Cell: ${cellSize}px. Initial color: ${currColor.toCSS()}`);
        }

        function handlePixelClick(path, event, isDrag = false) {
            const isLeftClick = event.event.button === 0;
            const isRightClick = event.event.button === 2;

            if (isDrag && path.gridX === lastPaintedCoords.x && path.gridY === lastPaintedCoords.y) {
                 return; // Vermeide unn√∂tiges Neuzeichnen derselben Zelle beim Ziehen
            }
            // console.log(`Click: Tool=${currentTool}, L=${isLeftClick}, R=${isRightClick}, Color=${currColor.toCSS()}, Target=(${path.gridX},${path.gridY}), CurrentFill=${path.fillColor?.toCSS()}`); // Debug

            let redrawNeeded = false;

            switch (currentTool) {
                case 'draw':
                    if (isLeftClick) {
                        // Male nur, wenn die neue Farbe anders ist als die aktuelle
                        if (!path.fillColor || !path.fillColor.equals(currColor)) {
                           path.fillColor = currColor.clone();
                           redrawNeeded = true;
                        //    console.log(`Draw: Set pixel (${path.gridX},${path.gridY}) to ${currColor.toCSS()}`);
                        }
                    } else if (isRightClick) {
                        // Radiere nur, wenn der Pixel nicht bereits transparent ist
                        if (path.fillColor !== null) {
                           path.fillColor = null; // Radieren (transparent)
                           redrawNeeded = true;
                        //    console.log(`Erase: Set pixel (${path.gridX},${path.gridY}) to null`);
                        }
                    }
                    break;
                case 'fill':
                    if (isLeftClick) {
                         // floodFill behandelt Neuzeichnen intern
                         floodFill(path.gridX, path.gridY, currColor);
                         redrawNeeded = false; // Wird von floodFill √ºbernommen
                    }
                    break;
                 case 'eyedropper':
                     if (isLeftClick) {
                         const pickedColorObj = path.fillColor || whiteColor; // Nimm Wei√ü, wenn transparent
                         // console.log(`Eyedropper: Picked ${pickedColorObj.toCSS()} from (${path.gridX},${path.gridY})`);
                         colorPicker.color.hexString = pickedColorObj.toHex(); // Update Picker
                         inputColorHex.value = pickedColorObj.toHex();       // Update Input
                         currColor = pickedColorObj.clone();                 // Update globale Farbe direkt
                         setActiveTool('draw'); // Wechsle zur√ºck
                         // Kein Neuzeichnen n√∂tig, nur UI-Update
                     }
                     break;
            }

             // Aktualisiere letzte Koordinate *nach* der Aktion
             lastPaintedCoords = { x: path.gridX, y: path.gridY };
             if (redrawNeeded) {
                 paperScope.view.draw(); // Zeichne nur neu, wenn n√∂tig
             }
        }

        function floodFill(startX, startY, newColor) {
            const targetPathObj = getPixelPath(startX, startY);
            if (!targetPathObj) return;

            const targetColor = targetPathObj.pixel.fillColor; // Kann null sein

            // Ist die Zielfarbe = neue Farbe? (Behandle null korrekt)
            const isNewColorNull = !newColor;
            const isTargetColorNull = !targetColor;
            if (isNewColorNull && isTargetColorNull) return; // null -> null
            if (!isNewColorNull && !isTargetColorNull && newColor.equals(targetColor)) return; // color -> same color

            // console.log(`Flood Fill: Start (${startX},${startY}), Target: ${targetColor?.toCSS()}, New: ${newColor?.toCSS()}`);

            const queue = [{ x: startX, y: startY }];
            const visited = new Set([`${startX},${startY}`]);
            let pixelsChanged = 0;

             while (queue.length > 0) {
                const { x, y } = queue.shift();
                const currentPathObj = getPixelPath(x, y);
                if (!currentPathObj) continue;

                // Setze die neue Farbe (Klon oder null)
                currentPathObj.pixel.fillColor = newColor ? newColor.clone() : null;
                pixelsChanged++;

                const neighbors = [ { nx: x, ny: y - 1 }, { nx: x, ny: y + 1 }, { nx: x - 1, ny: y }, { nx: x + 1, ny: y } ];

                for (const { nx, ny } of neighbors) {
                     const neighborKey = `${nx},${ny}`;
                     if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited.has(neighborKey)) {
                        const neighborPathObj = getPixelPath(nx, ny);
                         if (neighborPathObj) {
                            const neighborColor = neighborPathObj.pixel.fillColor;
                            const isNeighborColorNull = !neighborColor;
                            let match = false;
                            if (isTargetColorNull && isNeighborColorNull) match = true; // Beide transparent
                            else if (!isTargetColorNull && !isNeighborColorNull && targetColor.equals(neighborColor)) match = true; // Beide gleiche Farbe

                            if (match) {
                                visited.add(neighborKey);
                                queue.push({ x: nx, y: ny });
                            }
                         }
                     }
                 }
            }

            if (pixelsChanged > 0) {
                // console.log(`Flood Fill: Changed ${pixelsChanged} pixels.`);
                paperScope.view.draw();
            }
        }

        // Hilfsfunktion: Holt das Pfad-Objekt {x, y, pixel} f√ºr gegebene Grid-Koordinaten
        function getPixelPath(x, y) {
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                // Indexberechnung: Spaltenweise gef√ºllt (√§u√üere Schleife x, innere y)
                const index = x * gridSize + y;
                if (index < paths.length) {
                  return paths[index];
                }
            }
            console.warn(`getPixelPath: Invalid coords (${x}, ${y}) or index out of bounds.`);
            return null;
        }

        // --- Button Actions ---
        btnUpdateGrid.addEventListener('click', createGrid);

        btnGenerateMatrix.addEventListener('click', () => {
            if (!paperScope || paths.length === 0) {
                matrixDiv.textContent = "Grid is not initialized.";
                return;
            }
            console.log("Generating Matrix...");

            let colorMap = {}; // Map von Farb-Schl√ºssel (Hex oder TRANSPARENT_KEY) zu Zeichen { key: char }
            let colorDefinitions = {}; // Map von Farb-Schl√ºssel zu RGB-Array { key: [r, g, b] }
            let charCode = 97; // 'a'

            // 1. Durchlauf: Finde alle einzigartigen Farben (au√üer wei√ü/transparent) und weise Zeichen zu
            paths.forEach(p => {
                const color = p.pixel.fillColor;
                let key;
                let isRealColor = false;

                if (color && !color.equals(whiteColor)) {
                    // Es ist eine Farbe (nicht null und nicht wei√ü)
                    key = color.toHex(); // #rrggbb als Schl√ºssel
                    isRealColor = true;
                } else {
                    // Es ist transparent (null) oder wei√ü
                    key = TRANSPARENT_KEY;
                }

                // Wenn es eine neue "echte" Farbe ist, f√ºge sie zur Map hinzu
                if (isRealColor && !(key in colorMap)) {
                    const char = String.fromCharCode(charCode++);
                    colorMap[key] = char;
                    // Speichere RGB-Werte f√ºr die Definition (0-255)
                    colorDefinitions[key] = [
                        Math.round(color.red * 255),
                        Math.round(color.green * 255),
                        Math.round(color.blue * 255)
                    ];
                    // console.log(`Mapped color ${key} to char '${char}' (RGB: ${colorDefinitions[key]})`);
                }
            });

            // 2. Baue den Output-String
            let matrixOutput = "Color Definitions:\n";
            // F√ºge Definitionen f√ºr die gefundenen Farben hinzu
            for (const key in colorMap) {
                if (key !== TRANSPARENT_KEY) {
                    const char = colorMap[key];
                    const rgb = colorDefinitions[key];
                    matrixOutput += `${char} = (${rgb.join(',')}) - ${key}\n`; // Zeige auch Hex
                }
            }
            matrixOutput += "\nMatrix:\n";

            // 3. Gehe durch das Grid Reihe f√ºr Reihe und generiere die Matrix-Zeichen
            for (let j = 0; j < gridSize; j++) { // Reihen (y)
                let rowChars = [];
                for (let i = 0; i < gridSize; i++) { // Spalten (x)
                    const pathObj = getPixelPath(i, j); // Pixel bei (x=i, y=j) holen
                    let char = '.'; // Standard f√ºr wei√ü/transparent

                    if (pathObj && pathObj.pixel.fillColor && !pathObj.pixel.fillColor.equals(whiteColor)) {
                        // Es ist eine Farbe (nicht null, nicht wei√ü)
                        const key = pathObj.pixel.fillColor.toHex();
                        if (key in colorMap) {
                            char = colorMap[key]; // Zugeordnetes Zeichen holen
                        } else {
                            console.warn(`Matrix Generation: Color ${key} at (${i},${j}) not found in colorMap!`);
                            char = '?'; // Fehlerzeichen
                        }
                    }
                    rowChars.push(char);
                }
                // F√ºge die Zeile zum Output hinzu, mit Komma am Ende (au√üer letzte Zeile)
                matrixOutput += rowChars.join(", ") + (j < gridSize - 1 ? "," : "") + "\n";
            }

            matrixDiv.textContent = matrixOutput;
            console.log("Matrix generation complete.");
        });

        btnReset.addEventListener('click', () => {
            if (!paperScope) return;
            console.log("Resetting grid.");
            paths.forEach(p => {
                p.pixel.fillColor = null;
            });
            colorPicker.color.hexString = '#ffffff';
            inputColorHex.value = '#ffffff';
            currColor = whiteColor.clone();
            matrixDiv.textContent = 'Grid reset. Click "Generate Matrix" again.';
            paperScope.view.draw();
        });

        btnBlackify.addEventListener('click', () => {
            if (!paperScope) return;
            console.log("Blackifying blank/white pixels.");
            let changed = 0;
            paths.forEach(p => {
                if (!p.pixel.fillColor || p.pixel.fillColor.equals(whiteColor)) {
                    p.pixel.fillColor = blackColor.clone();
                    changed++;
                }
            });
            if (changed > 0) paperScope.view.draw();
            console.log(`Blackified ${changed} pixels.`);
        });

         btnToggleGridlines.addEventListener('click', () => {
             if (!paperScope) return;
             showGridLines = !showGridLines;
             const stroke = showGridLines ? blackColor : null;
             paths.forEach(p => {
                 // Klonen der Farbe ist sicherer, falls strokeColor modifiziert wird
                 p.pixel.strokeColor = stroke ? stroke.clone() : null;
             });
             // Aktualisiere Button Text und Icon Zustand
             const textNode = Array.from(btnToggleGridlines.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
             if(textNode) textNode.nodeValue = showGridLines ? ' Hide Grid Lines' : ' Show Grid Lines';
             btnToggleGridlines.classList.toggle('icon-grid', showGridLines);

             paperScope.view.draw();
             console.log("Toggled grid lines visibility to:", showGridLines);
         });

        btnExportPng.addEventListener('click', () => {
            if (!paperScope) return;
            console.log("Exporting as PNG...");
            paperScope.view.draw(); // Sicherstellen, dass alles gezeichnet ist

            const originalStrokes = [];
            if (showGridLines) { // Tempor√§r Linien entfernen
                paths.forEach(p => {
                    originalStrokes.push({ path: p.pixel, strokeColor: p.pixel.strokeColor, strokeWidth: p.pixel.strokeWidth });
                    p.pixel.strokeColor = null;
                });
                paperScope.view.draw();
            }

            const canvasElement = paperScope.view.element;
            const dataURL = canvasElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'pixel-art.png';
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            console.log("PNG export initiated.");

            if (showGridLines && originalStrokes.length > 0) { // Linien wiederherstellen
                originalStrokes.forEach(item => {
                   if(item.path) {
                       item.path.strokeColor = item.strokeColor; // Kein Klonen n√∂tig, da wir Originalobjekte wiederherstellen
                       item.path.strokeWidth = item.strokeWidth;
                   }
                });
                 paperScope.view.draw();
                 console.log("Restored grid lines after export.");
            }
        });

        btnColorInputOk.addEventListener('click', () => {
            if (!paperScope) return;
            const hexValue = inputColorHex.value.trim();
            try {
                // Striktere Pr√ºfung auf #rrggbb oder #rgb
                if (/^#([0-9A-F]{3}){1,2}$/i.test(hexValue)) {
                   const newColor = new paperScope.Color(hexValue);
                   colorPicker.color.hexString = newColor.toHex(); // Synchronisiere Picker
                   currColor = newColor; // Setze globale Farbe
                   console.log("Color set from input:", currColor.toCSS());
                } else {
                    throw new Error("Invalid hex format. Use #rrggbb or #rgb.");
                }
            } catch (e) {
                console.error("Invalid color input:", hexValue, e);
                alert(e.message || "Invalid color format.");
                // Setze Input zur√ºck auf aktuelle Farbe
                inputColorHex.value = currColor.toHex();
            }
        });

        inputColorHex.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                btnColorInputOk.click();
            }
        });

        // --- Initial Setup ---
        inputGridSize.value = gridSize;
        inputCellSize.value = cellSize;
        setActiveTool('draw');
        createGrid(); // Erstelle das initiale Grid beim Laden
        console.log("Pixel Matrix Editor Initialized.");
    });
  </script>
</body>
</html>
