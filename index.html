<!DOCTYPE html>
<html lang="de">
<!-- HEAD und CSS bleiben gleich -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Matrix Editor</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.17/paper-full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"></script>
  <style>
    /* CSS hier einf√ºgen */
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #f5f5f5;
      --border-color: #ccc;
      --text-color: #333;
      --canvas-border: #888;
      --active-tool-bg: #e0e0e0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--secondary-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      width: 100%;
      max-width: 1200px;
    }

    .controls, .canvas-container, .output-container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 280px;
    }

    .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #cv {
      border: 2px solid var(--canvas-border);
      cursor: crosshair; /* Standard-Cursor */
      margin-bottom: 15px;
       /* Verhindert das Ziehen von Bildern */
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      /* WICHTIG: Verhindert Standard-Browserverhalten bei Drag-Events auf dem Canvas */
      touch-action: none;
    }

     #cv.eyedropper-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='black' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z'/><path d='M12 14l6.36-6.36'/><path d='M8.5 8.5l7 7'/></svg>") 8 8, crosshair;
    }

    #cv.fill-cursor {
        cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='black'><path d='M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 18v-6h4v6h-4z'/></svg>") 8 16, pointer; /* Farbeimer-artiger Cursor */
    }

    .control-group {
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 15px;
    }

    .control-group legend {
      font-weight: bold;
      padding: 0 5px;
      color: var(--primary-color);
    }

     .control-group label,
     .control-group button {
        margin-bottom: 8px; /* F√ºgt etwas Platz unter Labels und Buttons hinzu */
     }

    .control-group input[type="number"],
    .control-group input[type="text"] {
      width: calc(100% - 16px); /* Volle Breite minus Padding */
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-top: 4px;
    }

    .control-group input[type="checkbox"] {
        margin-right: 5px;
        vertical-align: middle;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      font-size: 1em;
      margin: 5px 2px; /* Etwas Rand hinzugef√ºgt */
      display: inline-flex; /* Richtet Icon und Text aus */
      align-items: center; /* Richtet Icon und Text aus */
      gap: 5px; /* Platz zwischen Icon und Text */
    }

    button:hover {
      background-color: #3a7ac2;
    }

    button.secondary {
        background-color: #6c757d;
    }
    button.secondary:hover {
        background-color: #5a6268;
    }

    button.danger {
        background-color: #dc3545;
    }
    button.danger:hover {
        background-color: #c82333;
    }

    button.tool-button.active {
        background-color: var(--active-tool-bg);
        color: var(--text-color);
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }

    #color-picker-container {
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    .iro__slider {
        border-radius: 4px; /* Leicht abgerundeter Slider */
    }
    .iro__marker {
        border: 2px solid white; /* Macht den Marker sichtbarer */
        box-shadow: 0 0 3px rgba(0,0,0,0.5);
    }

    .color-input-group {
        display: flex;
        gap: 5px;
        align-items: center;
    }
     .color-input-group input[type="text"] {
        flex-grow: 1;
        margin-top: 0; /* √úberschreibt allgemeinen Rand */
        margin-bottom: 0; /* √úberschreibt allgemeinen Rand */
     }
    .color-input-group button {
        padding: 8px 10px;
        margin: 0; /* √úberschreibt allgemeinen Rand */
    }

    #matrix {
      white-space: pre;
      font-family: 'Courier New', Courier, monospace;
      background-color: #e9e9e9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid var(--border-color);
      max-height: 400px;
      overflow: auto;
      text-align: left;
      line-height: 1.4;
    }

    /* Einfache Icons mit Zeichen f√ºr Demo */
     .icon-fill::before { content: "üíß"; margin-right: 4px;}
     .icon-eyedropper::before { content: "üß™"; margin-right: 4px; }
     .icon-draw::before { content: "‚úèÔ∏è"; margin-right: 4px; }
     .icon-reset::before { content: "üîÑ"; margin-right: 4px; }
     .icon-export::before { content: "üíæ"; margin-right: 4px; }
     .icon-grid::before { content: "‚ñ¶"; margin-right: 4px; }
     .icon-done::before { content: "‚úÖ"; margin-right: 4px; }
     .icon-blackify::before { content: "‚¨õ"; margin-right: 4px; }
  </style>
</head>
<body>
    <!-- HTML Struktur bleibt gleich -->
    <h1>Pixel Matrix Editor</h1>

      <div class="container">

        <div class="controls">
          <fieldset class="control-group">
            <legend>Grid Settings</legend>
            <label for="grid-size">Grid Size (N x N):</label>
            <input type="number" id="grid-size" value="8" min="4" max="64">
            <label for="cell-size">Cell Size (px):</label>
            <input type="number" id="cell-size" value="30" min="5" max="50">
            <button id="update-grid">Update Grid</button>
          </fieldset>

          <fieldset class="control-group">
            <legend>Color</legend>
            <div id="color-picker-container">
              <div id="color-picker"></div> <!-- Wird von iro.js gef√ºllt -->
            </div>
             <div class="color-input-group">
                <input type="text" id="color-input" placeholder="#rrggbb">
                <button id="color-input-ok" title="Set color from input">OK</button>
             </div>
            <div>
              <input type="checkbox" id="changeforall" style="vertical-align: middle;">
              <label for="changeforall">Apply to all non-white/transparent pixels</label>
            </div>
          </fieldset>

           <fieldset class="control-group">
                <legend>Tools (Active: <span id="current-tool-display">Draw</span>)</legend>
                <button id="tool-draw" class="tool-button active icon-draw" title="Draw/Erase Tool (Left/Right Click)">Draw</button>
                <button id="tool-fill" class="tool-button icon-fill" title="Fill Tool">Fill</button>
                <button id="tool-eyedropper" class="tool-button icon-eyedropper" title="Eyedropper Tool">Pick Color</button>
            </fieldset>

          <fieldset class="control-group">
            <legend>Actions</legend>
            <button id="done" class="icon-done">Generate Matrix</button>
            <button id="reset" class="secondary icon-reset">Reset Grid</button>
            <button id="blackify" class="secondary icon-blackify">Fill Blank with Black</button>
             <button id="toggle-gridlines" class="secondary icon-grid">Toggle Grid Lines</button>
            <button id="export-png" class="icon-export">Export as PNG</button>
          </fieldset>
        </div>

        <div class="canvas-container">
          <canvas id="cv"></canvas>
        </div>

        <div class="output-container">
          <h2>Matrix Output</h2>
          <div id="matrix">Click "Generate Matrix" to see the output here.</div>
        </div>

      </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded. Initializing Pixel Editor...");

        // --- Elemente holen ---
        const canvas = document.getElementById("cv");
        const matrixDiv = document.getElementById("matrix");
        const btnGenerateMatrix = document.getElementById("done");
        const btnReset = document.getElementById("reset");
        const btnBlackify = document.getElementById("blackify");
        const btnExportPng = document.getElementById("export-png");
        const btnUpdateGrid = document.getElementById("update-grid");
        const btnToggleGridlines = document.getElementById("toggle-gridlines");
        const inputGridSize = document.getElementById("grid-size");
        const inputCellSize = document.getElementById("cell-size");
        const inputChangeAll = document.getElementById("changeforall");
        const inputColorHex = document.getElementById("color-input");
        const btnColorInputOk = document.getElementById("color-input-ok");
        const toolDrawBtn = document.getElementById('tool-draw');
        const toolFillBtn = document.getElementById('tool-fill');
        const toolEyedropperBtn = document.getElementById('tool-eyedropper');
        const currentToolDisplay = document.getElementById('current-tool-display');
        const colorPickerContainer = document.getElementById('color-picker');

        // --- Globale Zustandsvariablen ---
        let paperScope;
        let paths = [];
        let gridSize = 8;
        let cellSize = 30;
        let currColor; // Initialisiert in createGrid
        let isMouseDown = false;
        let lastPaintedCoords = { x: -1, y: -1 };
        let showGridLines = true;
        let currentTool = 'draw';
        let whiteColor; // Initialisiert in createGrid
        let blackColor; // Initialisiert in createGrid
        const TRANSPARENT_KEY = '__TRANSPARENT__';
        let isPaperReady = false; // <<< NEUE Variable zur Steuerung

        // --- Color Picker Initialisierung (iro.js) ---
        let colorPickerInstance;
        try {
             colorPickerInstance = new iro.ColorPicker(colorPickerContainer, {
                width: 200, color: "#ffffff", borderWidth: 1, borderColor: "#ccc",
                layout: [ { component: iro.ui.Wheel }, { component: iro.ui.Box },
                          { component: iro.ui.Slider, options: { sliderType: 'hue' } },
                          { component: iro.ui.Slider, options: { sliderType: 'saturation' } },
                          { component: iro.ui.Slider, options: { sliderType: 'value' } }, ]
            });
            console.log("iro.js Color Picker initialized.");

             // --- Event Listener f√ºr Color Picker ---
             // WICHTIG: Wird HIER definiert, aber der Code darin pr√ºft auf isPaperReady
             colorPickerInstance.on('color:change', (color) => {
                // *** NEUE PR√úFUNG: Nur ausf√ºhren, wenn Paper.js bereit ist ***
                if (!isPaperReady || !paperScope || !currColor || !whiteColor) {
                    console.log("Color Picker change event ignored - Paper.js not ready yet.");
                    return;
                }

                try {
                     const newColor = new paperScope.Color(color.hexString);

                     if (!currColor.equals(newColor)) {
                         // console.log("Picker changed color to:", newColor.toCSS());
                         currColor = newColor; // Globale Variable aktualisieren
                         inputColorHex.value = currColor.toHex(); // UI aktualisieren

                         // "Change for all" Logik
                         if (inputChangeAll.checked && paths.length > 0) {
                             paths.forEach(p => {
                                 if (p && p.pixel && p.pixel.fillColor && !p.pixel.fillColor.equals(whiteColor)) {
                                      p.pixel.fillColor = currColor.clone();
                                 }
                              });
                              paperScope.view.draw(); // Neuzeichnen
                         }
                     }
                 } catch (error) {
                     console.error("Error in color:change handler:", error);
                 }
             });
             console.log("Color Picker 'color:change' listener attached.");

        } catch (error) {
            console.error("FATAL: Failed to initialize iro.js Color Picker!", error);
            alert("Error initializing color picker. Please check console.");
            return;
        }

        // --- Hauptfunktionen ---

        function createGrid() {
            console.log("Attempting to create grid...");
            isPaperReady = false; // Zur√ºcksetzen, falls Grid neu erstellt wird
            try {
                if (paperScope && paperScope.project) {
                    paperScope.project.clear();
                    console.log("Cleared previous paper project.");
                }

                paperScope = new paper.PaperScope();
                paperScope.setup(canvas);
                console.log("paperScope setup complete on canvas.");

                // Farben initialisieren
                 try {
                    whiteColor = new paperScope.Color('white');
                    blackColor = new paperScope.Color('black');
                    if (!whiteColor || typeof whiteColor.clone !== 'function') throw new Error("Failed to init whiteColor");
                    console.log("Initialized whiteColor OK:", whiteColor.toString());

                    currColor = whiteColor.clone(); // Startfarbe ist wei√ü
                    if (!currColor || typeof currColor.toHex !== 'function') throw new Error("Failed to init currColor");
                    console.log("Initialized currColor OK:", currColor.toString());

                    // UI synchronisieren - HIER WAR DER VERMUTETE FEHLERORT, sollte jetzt sicher sein
                    colorPickerInstance.color.hexString = currColor.toHex();
                    inputColorHex.value = currColor.toHex();
                    console.log("Synced UI with initial currColor.");

                } catch (colorError) {
                    console.error("FATAL ERROR during color initialization:", colorError);
                    throw colorError; // Fehler weiterwerfen, um createGrid abzubrechen
                }

                // Grid-Parameter holen & Canvas Gr√∂√üe setzen
                paths = [];
                gridSize = parseInt(inputGridSize.value, 10) || 8;
                cellSize = parseInt(inputCellSize.value, 10) || 30;
                const totalSize = gridSize * cellSize;
                if (totalSize <= 0) throw new Error(`Invalid grid dimensions: Size=${gridSize}, Cell=${cellSize}`);
                canvas.width = totalSize;
                canvas.height = totalSize;
                paperScope.view.viewSize = new paperScope.Size(totalSize, totalSize);
                console.log(`Grid dimensions set: ${gridSize}x${gridSize}, Cell: ${cellSize}px`);

                // Pfade erstellen
                const strokeColor = showGridLines ? blackColor : null;
                for (let i = 0; i < gridSize; i++) { for (let j = 0; j < gridSize; j++) {
                        const rect = new paperScope.Rectangle(i * cellSize, j * cellSize, cellSize, cellSize);
                        const path = new paperScope.Path.Rectangle(rect);
                        path.fillColor = null; path.strokeColor = strokeColor ? strokeColor.clone() : null; path.strokeWidth = 1;
                        path.gridX = i; path.gridY = j;
                        path.onMouseDown = function(event) { if (!isPaperReady) return; event.preventDefault(); isMouseDown = true; handlePixelClick(this, event); };
                        path.onMouseEnter = function(event) { if (!isPaperReady || !isMouseDown) return; handlePixelClick(this, event, true); };
                        paths[i * gridSize + j] = { x: i, y: j, pixel: path };
                }}
                console.log(`Created ${paths.length} paths.`);

                // Globale Maus-Events
                paperScope.view.onMouseUp = () => { if (isMouseDown) { isMouseDown = false; lastPaintedCoords = { x: -1, y: -1 }; }};
                paperScope.view.onMouseLeave = () => { if (isMouseDown) { isMouseDown = false; lastPaintedCoords = { x: -1, y: -1 }; }};
                canvas.removeEventListener('contextmenu', preventContextMenu);
                canvas.addEventListener('contextmenu', preventContextMenu);

                // Alles zeichnen & Bereit-Status setzen
                paperScope.view.draw();
                isPaperReady = true; // <<< WICHTIG: Erst hier auf true setzen
                console.log("Grid creation complete. isPaperReady = true. Initial draw performed.");

            } catch (error) {
                isPaperReady = false; // Sicherstellen, dass es false ist bei Fehler
                console.error("FATAL ERROR during createGrid execution:", error);
                matrixDiv.textContent = "Error creating grid. See console.";
            }
        }

        function preventContextMenu(e) { e.preventDefault(); }

        // --- Andere Funktionen (handlePixelClick, floodFill, getPixelPath, setActiveTool, generateMatrix) ---
        // --- bleiben unver√§ndert zur letzten funktionierenden Version ---
        // F√ºge Sicherheitschecks hinzu, z.B. if (!isPaperReady) return; am Anfang jeder Funktion, die paperScope ben√∂tigt.

        function handlePixelClick(path, event, isDrag = false) {
            if (!isPaperReady || !paperScope || !path || !currColor || !whiteColor) {
                console.warn("handlePixelClick ignored - Paper.js not ready or missing variables.");
                return;
            }
            // Rest der Funktion...
            const isLeftClick = event.event.button === 0;
            const isRightClick = event.event.button === 2;

            if (isDrag && path.gridX === lastPaintedCoords.x && path.gridY === lastPaintedCoords.y) {
                 return;
            }

            let redrawNeeded = false;

            try {
                switch (currentTool) {
                    case 'draw':
                        if (isLeftClick) {
                            if (!path.fillColor || !path.fillColor.equals(currColor)) {
                               path.fillColor = currColor.clone();
                               redrawNeeded = true;
                            }
                        } else if (isRightClick) {
                            if (path.fillColor !== null) {
                               path.fillColor = null;
                               redrawNeeded = true;
                            }
                        }
                        break;
                    case 'fill':
                        if (isLeftClick) {
                             floodFill(path.gridX, path.gridY, currColor);
                             redrawNeeded = false;
                        }
                        break;
                     case 'eyedropper':
                         if (isLeftClick) {
                             const pickedColorObj = path.fillColor ? path.fillColor.clone() : whiteColor.clone();
                             colorPickerInstance.color.hexString = pickedColorObj.toHex();
                             inputColorHex.value = pickedColorObj.toHex();
                             currColor = pickedColorObj;
                             setActiveTool('draw');
                         }
                         break;
                }
            } catch (error) {
                 console.error("Error during handlePixelClick action:", error);
            }

            lastPaintedCoords = { x: path.gridX, y: path.gridY };
            if (redrawNeeded) {
                paperScope.view.draw();
            }
        }

        function floodFill(startX, startY, newColor) {
             if (!isPaperReady || !paperScope) { console.warn("floodFill ignored - Paper.js not ready."); return; }
             // Rest der Funktion...
            const targetPathObj = getPixelPath(startX, startY);
            if (!targetPathObj) { return; } // getPixelPath loggt schon

            const targetColor = targetPathObj.pixel.fillColor;
            const isNewColorNull = !newColor;
            const isTargetColorNull = !targetColor;

            if (isNewColorNull && isTargetColorNull) return;
            if (!isNewColorNull && !isTargetColorNull && newColor.equals(targetColor)) return;

            const queue = [{ x: startX, y: startY }];
            const visited = new Set([`${startX},${startY}`]);
            let pixelsChanged = 0;

             while (queue.length > 0) {
                const { x, y } = queue.shift();
                const currentPathObj = getPixelPath(x, y);
                if (!currentPathObj) continue;

                currentPathObj.pixel.fillColor = newColor ? newColor.clone() : null;
                pixelsChanged++;

                const neighbors = [ { nx: x, ny: y - 1 }, { nx: x, ny: y + 1 }, { nx: x - 1, ny: y }, { nx: x + 1, ny: y } ];

                for (const { nx, ny } of neighbors) {
                     const neighborKey = `${nx},${ny}`;
                     if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !visited.has(neighborKey)) {
                        const neighborPathObj = getPixelPath(nx, ny);
                         if (neighborPathObj) {
                            const neighborColor = neighborPathObj.pixel.fillColor;
                            const isNeighborColorNull = !neighborColor;
                            let match = false;
                            if (isTargetColorNull && isNeighborColorNull) match = true;
                            else if (!isTargetColorNull && !isNeighborColorNull && targetColor.equals(neighborColor)) match = true;

                            if (match) {
                                visited.add(neighborKey);
                                queue.push({ x: nx, y: ny });
                            }
                         }
                     }
                 }
            }
            if (pixelsChanged > 0) {
                paperScope.view.draw();
            }
        }

        function getPixelPath(x, y) {
             // Kein isPaperReady Check n√∂tig, da es nur Daten liest
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                const index = x * gridSize + y;
                // Pr√ºfe ob Index im Array liegt UND ob das Element existiert
                if (index < paths.length && paths[index]) {
                  return paths[index];
                }
            }
            // console.warn(`getPixelPath: Path not found for (${x}, ${y})`);
            return null;
        }

        function setActiveTool(toolName) {
             // Kein isPaperReady Check n√∂tig, UI √Ñnderung
            currentTool = toolName;
            currentToolDisplay.textContent = toolName.charAt(0).toUpperCase() + toolName.slice(1);
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`tool-${toolName}`);
            if (activeBtn) activeBtn.classList.add('active');

            canvas.classList.remove('eyedropper-cursor', 'fill-cursor');
            if (toolName === 'eyedropper') canvas.classList.add('eyedropper-cursor');
            else if (toolName === 'fill') canvas.classList.add('fill-cursor');
        }

        function generateMatrix() {
            if (!isPaperReady || !paperScope || !paths || paths.length === 0 || !whiteColor) {
                matrixDiv.textContent = "Grid/State not properly initialized.";
                console.warn("generateMatrix ignored - Paper.js not ready or missing prerequisites.");
                return;
            }
            // Rest der Funktion...
            console.log("Generating Matrix...");

            let colorMap = {};
            let colorDefinitions = {};
            let charCode = 97;
            const whiteHex = whiteColor.toHex();

            paths.forEach(p => {
                if (!p || !p.pixel) return;
                const color = p.pixel.fillColor;
                let key;
                let isRealColor = false;

                if (color) {
                    key = color.toHex();
                    if (key !== whiteHex) {
                        isRealColor = true;
                    } else {
                        key = TRANSPARENT_KEY;
                    }
                } else {
                    key = TRANSPARENT_KEY;
                }

                if (isRealColor && !(key in colorMap)) {
                    const char = String.fromCharCode(charCode++);
                    colorMap[key] = char;
                    try {
                       colorDefinitions[key] = [ Math.round(color.red * 255), Math.round(color.green * 255), Math.round(color.blue * 255) ];
                    } catch(e) {
                         console.error(`Error converting color ${key} to RGB`, e);
                         colorDefinitions[key] = null;
                    }
                }
            });

            let matrixOutput = "Color Definitions:\n";
            for (const key in colorMap) {
                if (key !== TRANSPARENT_KEY) {
                    const char = colorMap[key];
                    const rgb = colorDefinitions[key];
                    if (rgb && Array.isArray(rgb) && rgb.length === 3) {
                        matrixOutput += `${char} = (${rgb.join(',')}) - ${key}\n`;
                    } else {
                         matrixOutput += `${char} = (Error retrieving RGB) - ${key}\n`;
                    }
                }
            }
            matrixOutput += "\nMatrix:\n";

            for (let j = 0; j < gridSize; j++) {
                let rowChars = [];
                for (let i = 0; i < gridSize; i++) {
                    const pathObj = getPixelPath(i, j);
                    let char = '.';
                    let key = TRANSPARENT_KEY;

                    if (pathObj && pathObj.pixel && pathObj.pixel.fillColor) {
                        const currentHex = pathObj.pixel.fillColor.toHex();
                        if (currentHex !== whiteHex) {
                            key = currentHex;
                        }
                    }

                    if (key !== TRANSPARENT_KEY && key in colorMap) {
                        char = colorMap[key];
                    } else if (key !== TRANSPARENT_KEY) {
                        char = '?';
                    }
                    rowChars.push(char);
                }
                matrixOutput += rowChars.join(", ") + (j < gridSize - 1 ? "," : "") + "\n";
            }

            matrixDiv.textContent = matrixOutput;
        }


        // --- Event Listener f√ºr Buttons und Inputs ---

        btnUpdateGrid.addEventListener('click', createGrid);
        btnGenerateMatrix.addEventListener('click', generateMatrix);

        btnReset.addEventListener('click', () => {
            if (!isPaperReady || !paperScope || !paths || !whiteColor) return;
            paths.forEach(p => { if (p && p.pixel) p.pixel.fillColor = null; });
            colorPickerInstance.color.hexString = '#ffffff';
            inputColorHex.value = '#ffffff';
            currColor = whiteColor.clone();
            matrixDiv.textContent = 'Grid reset. Click "Generate Matrix" again.';
            paperScope.view.draw();
        });

        btnBlackify.addEventListener('click', () => {
             if (!isPaperReady || !paperScope || !paths || !whiteColor || !blackColor) return;
            let changed = 0;
            paths.forEach(p => {
                if (p && p.pixel && (!p.pixel.fillColor || p.pixel.fillColor.equals(whiteColor))) {
                    p.pixel.fillColor = blackColor.clone();
                    changed++;
                }
            });
            if (changed > 0) paperScope.view.draw();
        });

         btnToggleGridlines.addEventListener('click', () => {
             if (!isPaperReady || !paperScope || !paths || !blackColor) return;
             showGridLines = !showGridLines;
             const stroke = showGridLines ? blackColor : null;
             paths.forEach(p => {
                 if (p && p.pixel) p.pixel.strokeColor = stroke ? stroke.clone() : null;
             });
             const textNode = Array.from(btnToggleGridlines.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
             if(textNode) textNode.nodeValue = showGridLines ? ' Hide Grid Lines' : ' Show Grid Lines';
             btnToggleGridlines.classList.toggle('icon-grid', showGridLines);
             paperScope.view.draw();
         });

        btnExportPng.addEventListener('click', () => {
             if (!isPaperReady || !paperScope || !paperScope.view || !paperScope.view.element) return;
             paperScope.view.draw();

            const originalStrokes = [];
            let strokesChanged = false;
            if (showGridLines) {
                paths.forEach(p => {
                   if (p && p.pixel && p.pixel.strokeColor) {
                     originalStrokes.push({ path: p.pixel, strokeColor: p.pixel.strokeColor, strokeWidth: p.pixel.strokeWidth });
                     p.pixel.strokeColor = null;
                     strokesChanged = true;
                   }
                });
                if (strokesChanged) paperScope.view.draw();
            }

            try {
                const canvasElement = paperScope.view.element;
                const dataURL = canvasElement.toDataURL('image/png');
                const link = document.createElement('a'); link.download = 'pixel-art.png'; link.href = dataURL;
                document.body.appendChild(link); link.click(); document.body.removeChild(link);
            } catch (error) {
                 console.error("Error during PNG export:", error); alert("Failed to export PNG.");
            }

            if (strokesChanged) {
                originalStrokes.forEach(item => { if(item.path) { item.path.strokeColor = item.strokeColor; item.path.strokeWidth = item.strokeWidth; } });
                 paperScope.view.draw();
            }
        });

        btnColorInputOk.addEventListener('click', () => {
            if (!isPaperReady || !paperScope || !currColor || !colorPickerInstance) return;
            const hexValue = inputColorHex.value.trim();
            try {
                if (/^#([0-9A-F]{3}){1,2}$/i.test(hexValue)) {
                   const newColor = new paperScope.Color(hexValue);
                   colorPickerInstance.color.hexString = newColor.toHex();
                   currColor = newColor;
                } else {
                    throw new Error("Invalid hex format. Use #rrggbb or #rgb.");
                }
            } catch (e) {
                console.error("Invalid color input:", hexValue, e);
                alert(e.message || "Invalid color format.");
                inputColorHex.value = currColor.toHex();
            }
        });
        inputColorHex.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); btnColorInputOk.click(); } });

        toolDrawBtn.addEventListener('click', () => setActiveTool('draw'));
        toolFillBtn.addEventListener('click', () => setActiveTool('fill'));
        toolEyedropperBtn.addEventListener('click', () => setActiveTool('eyedropper'));

        // --- Initialer Start ---
        try {
            setActiveTool('draw');
            createGrid(); // Starte die Grid-Erstellung
            console.log("Initial setup call complete."); // Beachte: Grid ist evtl. noch nicht fertig
        } catch (error) {
            console.error("Error during initial setup call:", error);
            alert("Failed to initiate the editor. Please check the console.");
        }

    }); // Ende DOMContentLoaded
</script>

</body>
</html>

